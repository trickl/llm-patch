```typescript
// expression_evaluator.ts

type Token = { type: 'number' | 'operator' | 'parenthesis', value: string };

const precedence: { [key: string]: number } = {
  '+': 1,
  '-': 1,
  '*': 2,
  '/': 2
};

function tokenize(input: string): Token[] {
  const tokens: Token[] = [];
  let i = 0;

  while (i < input.length) {
    if (input[i] === ' ') {
      i++;
      continue;
    }

    if (!isNaN(Number(input[i])) || input[i] === '-') {
      let numStr = input[i];
      while (i + 1 < input.length && !isNaN(Number(input[i + 1])) || input[i + 1] === '.') {
        numStr += input[++i];
      }
      tokens.push({ type: 'number', value: numStr });
    } else if ('+-*/()'.includes(input[i])) {
      tokens.push({ type: 'operator', value: input[i] });
      i++;
    } else {
      throw new Error(`Unexpected character: ${input[i]}`);
    }
  }

  return tokens;
}

function parse(tokens: Token[]): number[] {
  const outputQueue: string[] = [];
  const operatorStack: string[] = [];

  for (const token of tokens) {
    if (token.type === 'number') {
      outputQueue.push(token.value);
    } else if (token.value === '(') {
      operatorStack.push(token.value);
    } else if (token.value === ')') {
      while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
        outputQueue.push(operatorStack.pop()!);
      }
      if (operatorStack.length === 0 || operatorStack.pop() !== '(') {
        throw new Error('Mismatched parentheses');
      }
    } else {
      while (
        operatorStack.length > 0 &&
        precedence[operatorStack[operatorStack.length - 1]] >= precedence[token.value]
      ) {
        outputQueue.push(operatorStack.pop()!);
      }
      operatorStack.push(token.value);
    }
  }

  while (operatorStack.length > 0) {
    outputQueue.push(operatorStack.pop()!);
  }

  return outputQueue;
}

function evaluate(outputQueue: string[]): number {
  const stack: number[] = [];

  for (const token of outputQueue) {
    if (!isNaN(Number(token))) {
      stack.push(Number(token));
    } else {
      const b = stack.pop()!;
      const a = stack.pop()!;
      switch (token) {
        case '+':
          stack.push(a + b);
          break;
        case '-':
          stack.push(a - b);
          break;
        case '*':
          stack.push(a * b);
          break;
        case '/':
          stack.push(Math.floor(a / b));
          break;
        default:
          throw new Error(`Unknown operator: ${token}`);
      }
    }
  }

  return stack[0];
}

export function evaluateExpression(input: string): number {
  const tokens = tokenize(input);
  const outputQueue = parse(tokens);
  return evaluate(outputQueue);
}

// CLI example
if (require.main === module) {
  const input = process.argv[2] || '3 + 4 * (2 - 1)';
  try {
    console.log(`Result: ${evaluateExpression(input)}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
  }
}
```

To run the CLI example, save the code to `expression_evaluator.ts` and execute it with Node.js:

```sh
node expression_evaluator.ts "2 * (3 + 4)"
```

This will output:

```
Result: 14
```