```typescript
// expression_evaluator.ts

type Token = { type: 'number' | 'operator' | 'parenthesis'; value: string };

function tokenize(input: string): Token[] {
    const tokens: Token[] = [];
    let i = 0;

    while (i < input.length) {
        if (/\s/.test(input[i])) {
            i++;
            continue;
        }

        if (/[\d]/.test(input[i])) {
            let num = '';
            while (i < input.length && /\d/.test(input[i])) {
                num += input[i];
                i++;
            }
            tokens.push({ type: 'number', value: num });
        } else if (/[-+*/()]/.test(input[i])) {
            tokens.push({ type: 'operator', value: input[i] });
            i++;
        } else {
            throw new Error(`Unexpected character: ${input[i]}`);
        }
    }

    return tokens;
}

function parse(tokens: Token[]): number[] {
    const values: number[] = [];
    const ops: string[] = [];

    function applyOp(a: number, b: number, op: string): number {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return Math.floor(a / b);
            default: throw new Error(`Invalid operator: ${op}`);
        }
    }

    function greaterPrecedence(op1: string, op2: string): boolean {
        if (op1 === '*' || op1 === '/') return true;
        if (op2 === '+' || op2 === '-') return true;
        return false;
    }

    for (const token of tokens) {
        if (token.type === 'number') {
            values.push(parseInt(token.value, 10));
        } else if (token.value === '(') {
            ops.push(token.value);
        } else if (token.value === ')') {
            while (ops.length && ops[ops.length - 1] !== '(') {
                const op = ops.pop()!;
                const b = values.pop()!;
                const a = values.pop()!;
                values.push(applyOp(a, b, op));
            }
            if (ops.length && ops[ops.length - 1] === '(') {
                ops.pop();
            }
        } else {
            while (ops.length && greaterPrecedence(ops[ops.length - 1], token.value)) {
                const op = ops.pop()!;
                const b = values.pop()!;
                const a = values.pop()!;
                values.push(applyOp(a, b, op));
            }
            ops.push(token.value);
        }
    }

    while (ops.length) {
        const op = ops.pop()!;
        const b = values.pop()!;
        const a = values.pop()!;
        values.push(applyOp(a, b, op));
    }

    return values;
}

export function evaluateExpression(input: string): number {
    try {
        const tokens = tokenize(input);
        const result = parse(tokens);
        if (result.length !== 1) throw new Error('Invalid expression');
        return result[0];
    } catch (error) {
        console.error(`Error evaluating expression: ${input}`);
        throw error;
    }
}

// Example CLI usage:
if (require.main === module) {
    const input = process.argv.slice(2).join(' ');
    try {
        const result = evaluateExpression(input);
        console.log(result);
    } catch (error) {
        // Error handling already done in evaluateExpression
    }
}
```

This TypeScript program defines a mini calculator that tokenizes, parses, and evaluates infix arithmetic expressions with parentheses, unary minus, and integer semantics. The `tokenize` function converts the input string into an array of tokens. The `parse` function handles operator precedence and uses a stack-based algorithm to evaluate the expression. The `evaluateExpression` function orchestrates the process and provides minimal error handling for malformed expressions. The CLI example demonstrates how to use the program from the command line.