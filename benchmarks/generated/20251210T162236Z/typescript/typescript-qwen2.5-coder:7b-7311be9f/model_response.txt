```typescript
// expression_evaluator.ts

type Token = { type: 'NUMBER' | 'PLUS' | 'MINUS' | 'MUL' | 'DIV' | 'LPAREN' | 'RPAREN' | 'UMINUS'; value?: number };

function tokenize(input: string): Token[] {
    const tokens: Token[] = [];
    let i = 0;

    while (i < input.length) {
        if (input[i] === ' ') {
            i++;
            continue;
        }

        if (!isNaN(Number(input[i]))) {
            let num = Number(input[i]);
            i++;
            while (i < input.length && !isNaN(Number(input[i]))) {
                num = num * 10 + Number(input[i]);
                i++;
            }
            tokens.push({ type: 'NUMBER', value: num });
        } else if (input[i] === '+') {
            tokens.push({ type: 'PLUS' });
            i++;
        } else if (input[i] === '-') {
            if (tokens.length === 0 || tokens[tokens.length - 1].type === 'LPAREN' || tokens[tokens.length - 1].type === 'UMINUS') {
                tokens.push({ type: 'UMINUS' });
            } else {
                tokens.push({ type: 'MINUS' });
            }
            i++;
        } else if (input[i] === '*') {
            tokens.push({ type: 'MUL' });
            i++;
        } else if (input[i] === '/') {
            tokens.push({ type: 'DIV' });
            i++;
        } else if (input[i] === '(') {
            tokens.push({ type: 'LPAREN' });
            i++;
        } else if (input[i] === ')') {
            tokens.push({ type: 'RPAREN' });
            i++;
        }
    }

    return tokens;
}

function parse(tokens: Token[]): number[] {
    const values: number[] = [];
    const ops: string[] = [];

    function applyOp(ops: string[], values: number[]): void {
        const b = values.pop()!;
        const a = values.pop()!;
        switch (ops.pop()!) {
            case '+':
                values.push(a + b);
                break;
            case '-':
                values.push(a - b);
                break;
            case '*':
                values.push(a * b);
                break;
            case '/':
                if (b === 0) throw new Error('Division by zero');
                values.push(Math.floor(a / b));
                break;
        }
    }

    function precedence(op: string): number {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0;
        }
    }

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === 'NUMBER') {
            values.push(token.value!);
        } else if (token.type === 'UMINUS') {
            values.push(-values.pop()!);
        } else if (token.type === 'LPAREN') {
            ops.push(token.type);
        } else if (token.type === 'RPAREN') {
            while (ops[ops.length - 1] !== '(') {
                applyOp(ops, values);
            }
            ops.pop();
        } else {
            while (ops.length && precedence(ops[ops.length - 1]) >= precedence(token.type)) {
                applyOp(ops, values);
            }
            ops.push(token.type);
        }
    }

    while (ops.length) {
        applyOp(ops, values);
    }

    return values;
}

export function evaluateExpression(input: string): number {
    const tokens = tokenize(input);
    const result = parse(tokens);
    if (result.length !== 1) throw new Error('Invalid expression');
    return result[0];
}

// CLI example
if (require.main === module) {
    console.log(evaluateExpression("3 + 4 * (2 - 1)")); // Output: 7
    console.log(evaluateExpression("2 * 3 + 4")); // Output: 10
    console.log(evaluateExpression("2 * (3 + 4)")); // Output: 14
    console.log(evaluateExpression("8 / 2 * (2 + 2)")); // Output: 16
}
```