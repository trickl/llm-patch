```java
import java.util.*;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        Tokenizer tokenizer = new Tokenizer(expression);
        Parser parser = new Parser(tokenizer);
        return parser.parse().result;
    }
}

class Tokenizer {
    private final String expression;
    private final List<Token> tokens;

    public Tokenizer(String expression) {
        this.expression = expression;
        this.tokens = tokenize();
    }

    private List<Token> tokenize() {
        List<Token> tokens = new ArrayList<>();
        StringBuilder currentToken = new StringBuilder();

        for (char c : expression.toCharArray()) {
            if (Character.isWhitespace(c)) {
                if (!currentToken.isEmpty()) {
                    tokens.add(new Token(TokenType.IDENTIFIER, currentToken.toString()));
                    currentToken.setLength(0);
                }
            } else if (c == '(' || c == ')') {
                tokens.add(new Token(TokenType.PARENTHESIS, String.valueOf(c)));
            } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                tokens.add(new Token(TokenType.OPERATOR, String.valueOf(c)));
            } else if (Character.isDigit(c)) {
                currentToken.append(c);
            }
        }

        if (!currentToken.isEmpty()) {
            tokens.add(new Token(TokenType.IDENTIFIER, currentToken.toString()));
        }

        return tokens;
    }
}

enum TokenType {
    IDENTIFIER,
    OPERATOR,
    PARENTHESIS
}

class Token {
    private final TokenType type;
    private final String value;

    public Token(TokenType type, String value) {
        this.type = type;
        this.value = value;
    }

    public TokenType getType() {
        return type;
    }

    public String getValue() {
        return value;
    }
}

class Parser {
    private final List<Token> tokens;
    private int index;

    public Parser(List<Token> tokens) {
        this.tokens = tokens;
        this.index = 0;
    }

    public Expression parse() {
        return parseExpression();
    }

    private Expression parseExpression() {
        Expression left = parseTerm();

        while (index < tokens.size()) {
            Token token = tokens.get(index);

            if (token.getType() == TokenType.OPERATOR) {
                switch (token.getValue()) {
                    case "+":
                        left = new BinaryOperator(left, "+", parseTerm());
                        break;
                    case "-":
                        left = new BinaryOperator(left, "-", parseTerm());
                        break;
                    case "*":
                        left = new BinaryOperator(left, "*", parseTerm());
                        break;
                    case "/":
                        left = new BinaryOperator(left, "/", parseTerm());
                        break;
                }
            } else if (token.getType() == TokenType.PARENTHESIS) {
                Expression right = parseExpression();
                index++; // consume the closing parenthesis
                return new Parenthetical(right);
            }

            index++;
        }

        return left;
    }

    private Term parseTerm() {
        Term left = parseFactor();

        while (index < tokens.size()) {
            Token token = tokens.get(index);

            if (token.getType() == TokenType.OPERATOR) {
                switch (token.getValue()) {
                    case "*":
                        left = new BinaryOperator(left, "*", parseFactor());
                        break;
                    case "/":
                        left = new BinaryOperator(left, "/", parseFactor());
                        break;
                }
            } else if (token.getType() == TokenType.PARENTHESIS) {
                Term right = parseTerm();
                index++; // consume the closing parenthesis
                return new Parenthetical(right);
            }

            index++;
        }

        return left;
    }

    private Factor parseFactor() {
        Token token = tokens.get(index);

        if (token.getType() == TokenType.IDENTIFIER) {
            index++;
            return new Literal(token.getValue());
        } else if (token.getType() == TokenType.PARENTHESIS) {
            Expression expression = parseExpression();
            index++; // consume the opening parenthesis
            return new Parenthetical(expression);
        } else if (token.getType() == TokenType.OPERATOR) {
            switch (token.getValue()) {
                case "-":
                    return new UnaryOperator("-", parseFactor());
            }
        }

        throw new RuntimeException("Invalid token");
    }

    private Expression new BinaryOperator(Expression left, String operator, Expression right) {
        return new BinaryOperator(left, operator, right);
    }

    private Expression new Parenthetical(Expression expression) {
        return new Parenthetical(expression);
    }

    private Expression new UnaryOperator(String operator, Expression operand) {
        return new UnaryOperator(operator, operand);
    }
}

class Expression {
    public int result;
}

class BinaryOperator extends Expression {
    private final Expression left;
    private final String operator;
    private final Expression right;

    public BinaryOperator(Expression left, String operator, Expression right) {
        this.left = left;
        this.operator = operator;
        this.right = right;
    }

    @Override
    public int result() {
        switch (operator) {
            case "+":
                return left.result() + right.result();
            case "-":
                return left.result() - right.result();
            case "*":
                return left.result() * right.result();
            case "/":
                return left.result() / right.result();
            default:
                throw new RuntimeException("Invalid operator");
        }
    }
}

class Parenthetical extends Expression {
    private final Expression expression;

    public Parenthetical(Expression expression) {
        this.expression = expression;
    }

    @Override
    public int result() {
        return expression.result();
    }
}

class UnaryOperator extends Expression {
    private final String operator;
    private final Expression operand;

    public UnaryOperator(String operator, Expression operand) {
        this.operator = operator;
        this.operand = operand;
    }

    @Override
    public int result() {
        switch (operator) {
            case "-":
                return -operand.result();
            default:
                throw new RuntimeException("Invalid operator");
        }
    }
}

class Literal extends Expression {
    private final String value;

    public Literal(String value) {
        this.value = value;
    }

    @Override
    public int result() {
        return Integer.parseInt(value);
    }
}
```