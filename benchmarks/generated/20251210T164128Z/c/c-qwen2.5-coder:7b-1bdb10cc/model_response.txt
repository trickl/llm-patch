```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_TOKENS 100

typedef enum {
    TOKEN_NUMBER,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MULTIPLY,
    TOKEN_DIVIDE,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_EOF
} TokenType;

typedef struct {
    TokenType type;
    int value;
} Token;

Token tokens[MAX_TOKENS];
int tokenIndex = 0;

void error(const char *message) {
    fprintf(stderr, "Error: %s\n", message);
    exit(EXIT_FAILURE);
}

Token getNextToken() {
    while (isspace(tokens[tokenIndex].value)) {
        tokenIndex++;
    }

    if (tokens[tokenIndex].type == TOKEN_EOF) {
        return tokens[tokenIndex];
    }

    Token token = tokens[tokenIndex++];
    switch (token.type) {
        case TOKEN_NUMBER:
            break;
        case TOKEN_PLUS:
        case TOKEN_MINUS:
        case TOKEN_MULTIPLY:
        case TOKEN_DIVIDE:
        case TOKEN_LPAREN:
        case TOKEN_RPAREN:
            break;
        default:
            error("Unexpected token");
    }
    return token;
}

int evaluateExpression() {
    int result = evaluateTerm();
    while (tokens[tokenIndex].type == TOKEN_PLUS || tokens[tokenIndex].type == TOKEN_MINUS) {
        TokenType operator = tokens[tokenIndex++].type;
        int nextTerm = evaluateTerm();
        if (operator == TOKEN_PLUS) {
            result += nextTerm;
        } else {
            result -= nextTerm;
        }
    }
    return result;
}

int evaluateTerm() {
    int result = evaluateFactor();
    while (tokens[tokenIndex].type == TOKEN_MULTIPLY || tokens[tokenIndex].type == TOKEN_DIVIDE) {
        TokenType operator = tokens[tokenIndex++].type;
        int nextFactor = evaluateFactor();
        if (operator == TOKEN_MULTIPLY) {
            result *= nextFactor;
        } else {
            result /= nextFactor;
        }
    }
    return result;
}

int evaluateFactor() {
    Token token = getNextToken();
    switch (token.type) {
        case TOKEN_NUMBER:
            return token.value;
        case TOKEN_PLUS:
            return evaluateExpression();
        case TOKEN_MINUS:
            return -evaluateExpression();
        case TOKEN_LPAREN:
            int result = evaluateExpression();
            if (tokens[tokenIndex++].type != TOKEN_RPAREN) {
                error("Expected ')'");
            }
            return result;
        default:
            error("Unexpected token");
    }
}

void tokenize(const char *expression) {
    tokenIndex = 0;
    for (int i = 0; expression[i]; i++) {
        if (isspace(expression[i])) continue;

        Token token;
        switch (expression[i]) {
            case '+':
                token.type = TOKEN_PLUS;
                break;
            case '-':
                token.type = TOKEN_MINUS;
                break;
            case '*':
                token.type = TOKEN_MULTIPLY;
                break;
            case '/':
                token.type = TOKEN_DIVIDE;
                break;
            case '(':
                token.type = TOKEN_LPAREN;
                break;
            case ')':
                token.type = TOKEN_RPAREN;
                break;
            default:
                if (isdigit(expression[i])) {
                    int value = 0;
                    while (i < strlen(expression) && isdigit(expression[i])) {
                        value = value * 10 + (expression[i++] - '0');
                    }
                    i--;
                    token.type = TOKEN_NUMBER;
                    token.value = value;
                } else {
                    error("Unexpected character");
                }
        }
        tokens[tokenIndex++] = token;
    }
    tokens[tokenIndex].type = TOKEN_EOF;
}

int main() {
    const char *expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    for (const char *expr : expressions) {
        tokenize(expr);
        int result = evaluateExpression();
        printf("%s => %d\n", expr, result);
    }
    return 0;
}
```