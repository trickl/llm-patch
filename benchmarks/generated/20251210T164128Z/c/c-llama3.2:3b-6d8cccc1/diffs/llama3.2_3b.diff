--- before.c
+++ patched_before.c
@@ -4,7 +4,8 @@
 #include  string.h>
 #include  ctype.h>
 
-#include  <string.h>
+#include  ctype.h>
 
 // Token type enum
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     END_OF_EXPRESSION
 } TokenType;
 
 // Token structure
 typedef struct {
     TokenType type;
     double value;
     char* str;
 } Token;
 
 // Lexer function to tokenize the input expression
+Token* lexer(char* expression) {
+    int length = strlen(expression);
+    Token* tokens = malloc((length + 1) * sizeof(Token));
+    for (int i = 0; i  length; i++) {
+        if (isdigit(expression[i])) {
+            int start = i;
+            while (i  length && isdigit(expression[i])) {
+                i++;
+            }
+            double value = atof(expression + start);
+            tokens[i - start] = {NUMBER, value, NULL};
+        } else if (expression[i] == '+') {
+            tokens[i] = {PLUS, 0, "+"};
+        } else if (expression[i] == '-') {
+            tokens[i] = {MINUS, 0, "-"};
+        } else if (expression[i] == '*') {
+            tokens[i] = {MUL, 0, "*"};
+        } else if (expression[i] == '/') {
+            tokens[i] = {DIV, 0, "/"};
+        } else if (expression[i] == '(') {
+            tokens[i] = {LPAREN, 0, NULL};
+        } else if (expression[i] == ')') {
+            tokens[i] = {RPAREN, 0, NULL};
+        } else if (expression[i] == '-') {
+            tokens[i] = {UNARY_MINUS, 0, "-"};
+        } else {
+            return NULL;
+        }
+    }
+    tokens[length] = {END_OF_EXPRESSION, 0, NULL};
+    return tokens;
+}
 
 // Parser function to parse the tokenized expression
 Token* parser(Token* tokens) {
     Token* current_token = tokens;
     while (current_token->type != END_OF_EXPRESSION && current_token->str != NULL) {
         if (current_token->type == LPAREN) {
             Token* sub_expression = parser(current_token + 1);
             if (sub_expression->type == RPAREN) {
                 return sub_expression;
             } else {
                 return NULL;
             }
         } else if (current_token->type == UNARY_MINUS) {
             current_token++;
             double value = -current_token->value;
             Token* next_token = current_token + 1;
             while (next_token->type != END_OF_EXPRESSION && next_token->str != NULL) {
                 if (next_token->type == NUMBER || next_token->type == PLUS || next_token->type == MINUS || next_token->type == MUL || next_token->type == DIV) {
                     break;
                 }
                 next_token++;
             }
             Token* new_current_token = malloc(sizeof(Token));
             new_current_token->type = current_token->type;
             new_current_token->value = value;
             new_current_token->str = NULL;
             new_current_token->next = next_token;
             current_token = new_current_token;
         } else {
             if (current_token->type == PLUS || current_token->type == MINUS) {
                 Token* next_token = current_token + 1;
                 while (next_token->type != END_OF_EXPRESSION && next_token->str != NULL) {
                     if (next_token->type == NUMBER || next_token->type == MUL || next_token->type == DIV) {
                         break;
                     }
                     next_token++;
                 }
                 Token* new_current_token = malloc(sizeof(Token));
                 new_current_token->type = current_token->type;
                 new_current_token->value = 0;
                 new_current_token->str = NULL;
                 if (current_token->type == PLUS) {
                     new_current_token->next = next_token;
                 } else {
                     new_current_token->next = next_token + 1;
                 }
                 current_token = new_current_token;
             } else if (current_token->type == MUL || current_token->type == DIV) {
                 Token* next_token = current_token + 1;
                 while (next_token->type != END_OF_EXPRESSION && next_token->str != NULL) {
                     if (next_token->type == NUMBER || next_token->type == PLUS || next_token->type == MINUS) {
                         break;
                     }
                     next_token++;
                 }
                 Token* new_current_token = malloc(sizeof(Token));
                 new_current_token->type = current_token->type;
                 new_current_token->value = 0;
                 new_current_token->str = NULL;
                 if (current_token->type == MUL) {
                     new_current_token->next = next_token;
                 } else {
                     new_current_token->next = next_token + 1;
                 }
                 current_token = new_current_token;
             }
         }
     }
     return current_token;
 }

 // Evaluator function to evaluate the parsed expression
 double evaluator(Token* token) {
     double result = token->value;
     Token* current_token = token;
     while (current_token->next != NULL && current_token->next->type == NUMBER) {
         double value = current_token->next->value;
         if (current_token->type == PLUS || current_token->type == MINUS) {
             result += value;
         } else if (current_token->type == MUL || current_token->type == DIV) {
             result /= value;
         }
         current_token = current_token->next;
     }
     return result;
 }

 int main() {
     char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
     for (char* expression : expressions) {
         Token* tokens = lexer(expression);
         if (tokens == NULL) {
             printf("Error: %s\n", expression);
             continue;
         }
         Token* parsed_expression = parser(tokens);
         if (parsed_expression == NULL) {
             printf("Error: %s\n", expression);
             free(tokens);
             continue;
         }
         double result = evaluator(parsed_expression);
         printf("%s => %f\n", expression, result);
         free(parsed_expression);
         free(tokens);
     }
     return 0;
 }
