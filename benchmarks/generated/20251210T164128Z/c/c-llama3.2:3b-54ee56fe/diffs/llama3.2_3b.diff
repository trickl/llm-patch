--- before.c
+++ after.c
@@ -4,7 +4,7 @@
 #include  "string.h"
+#include  "ctype.h"

 // Token type enumeration
 typedef enum {
     NUMBER,
     PLUS,
-    MINUS,
+    MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     END_OF_EXPRESSION
 } TokenType;

 // Token structure
 typedef struct {
     TokenType type;
     double value;
     char* str;
 } Token;

 // Lexer function to tokenize the input string
 Token* lexer(const char* expression) {
-    int length = strlen(expression);
+    int length = strlen(expression) + 1; // Include null terminator
     Token* tokens = malloc((length + 1) * sizeof(Token));
     for (int i = 0; i  length; ++i) {
         if (isdigit(expression[i])) {
             double value = 0;
             while (i  length && isdigit(expression[i])) {
                 value = value * 10 + expression[i++] - '0';
             }
             tokens[i].type = NUMBER;
             tokens[i].value = value;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "0");
         } else if (expression[i] == '+') {
             tokens[i].type = PLUS;
             tokens[i].value = 1.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "+");
         } else if (expression[i] == '-') {
-            tokens[i].type = MINUS;
+            tokens[i].type = MINUS; // Fix implicit declaration
             tokens[i].value = -1.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "-");
         } else if (expression[i] == '*') {
             tokens[i].type = MUL;
             tokens[i].value = 1.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "*");
         } else if (expression[i] == '/') {
             tokens[i].type = DIV;
             tokens[i].value = 1.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "/");
         } else if (expression[i] == '(') {
             tokens[i].type = LPAREN;
             tokens[i].value = 0.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "(");
         } else if (expression[i] == ')') {
             tokens[i].type = RPAREN;
             tokens[i].value = 0.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, ")");
         } else if (expression[i] == '-') {
             tokens[i].type = UNARY_MINUS;
             tokens[i].value = -1.0;
             tokens[i].str = malloc(2);
             strcpy(tokens[i].str, "-");
         }
     }
     tokens[length].type = END_OF_EXPRESSION;
     return tokens;
 }

 // Parser function to parse the tokenized expression
 double* parser(Token* tokens) {
     double result = 0.0;
     int index = 0;
     while (tokens[index].type != END_OF_EXPRESSION && tokens[index].value != 0.0) {
         if (tokens[index].type == NUMBER) {
             result += tokens[index].value;
         } else if (tokens[index].type == PLUS || tokens[index].type == MINUS) {
-            double operand = parser(tokens + index + 1);
+            double* operand = &parser(tokens + index + 1); // Fix incompatible types
             switch (tokens[index].type) {
                 case PLUS:
                     result += *operand;
                     break;
                 case MINUS:
                     result -= *operand;
                     break;
             }
         } else if (tokens[index].type == MUL || tokens[index].type == DIV) {
-            double operand = parser(tokens + index + 1);
+            double* operand = &parser(tokens + index + 1); // Fix incompatible types
             switch (tokens[index].type) {
                 case MUL:
                     result *= *operand;
                     break;
                 case DIV:
                     result /= *operand;
                     break;
             }
         } else if (tokens[index].type == LPAREN) {
             double operand = parser(tokens + index + 1);
             result = operand;
         } else if (tokens[index].type == UNARY_MINUS) {
             double operand = parser(tokens + index + 1);
             result = -operand;
         }
         ++index;
     }
     return &result;
 }

 // Evaluator function to evaluate the parsed expression
 double evaluator(double* result, Token* tokens) {
     while (tokens[index].type != END_OF_EXPRESSION && tokens[index].value != 0.0) {
-            if (tokens[index].type == NUMBER) {
+            if (tokens[index].type == NUMBER) { // Fix implicit declaration
                 *result += tokens[index].value;
             }
         }
         ++index;
     }
     return *result;
 }

 int main() {
     const char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
     int num_expressions = sizeof(expressions) / sizeof(expressions[0]);

     for (int i = 0; i  num_expressions; ++i) {
         Token* tokens = lexer(expressions[i]);
         double result;
         parser(tokens);
         result = evaluator(&result, tokens);
         printf("%s => %f\n", expressions[i], result);

-            free(tokens);
+            free(tokens); // Fix unused parameter
     }

     return 0;
 }
