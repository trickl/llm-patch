--- before.c
+++ patched_before.c
@@ -4,6 +4,7 @@
 #include  string.h>
+#include ctype.h>

 // Token type enum
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UMINUS,
     END_OF_INPUT
 } TokenType;

-// Token structure
+// Token structure
 typedef struct {
     TokenType type;
     double value;
     char* str;
 } Token;

 // Lexer function to tokenize input string
 Token* lexer(char* input) {
     int length = strlen(input);
     Token* tokens = malloc((length + 1) * sizeof(Token));
     for (int i = 0; i  length; ++i) {
-        if (isdigit(input[i])) {
+        if (isdigit(input[i])) {
             char* start = &input[i];
             while (isdigit(*start)) ++start;
             double value = atof(start);
             tokens[i].type = NUMBER;
             tokens[i].value = value;
             tokens[i].str = input + i;
         } else if (input[i] == '+') {
             tokens[i].type = PLUS;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == '-') {
             tokens[i].type = MINUS;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == '*') {
             tokens[i].type = MUL;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == '/') {
             tokens[i].type = DIV;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == '(') {
             tokens[i].type = LPAREN;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == ')') {
             tokens[i].type = RPAREN;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else if (input[i] == '-') {
             tokens[i].type = UMINUS;
             tokens[i].value = 0.0;
             tokens[i].str = "";
         } else {
             return NULL;
         }
     }
     tokens[length].type = END_OF_INPUT;
     tokens[length].value = 0.0;
     tokens[length].str = "";
     return tokens;
 }

 // Parser function to parse tokenized input
 double* parser(Token* tokens) {
     double* stack = malloc(100 * sizeof(double));
     int top = -1;
-    for (int i = 0; i  strlen(tokens[0].str); ++i) {
+    for (int i = 0; i  strlen(tokens[0].str); ++i) {
         if (tokens[i].type == LPAREN) {
             ++top;
         } else if (tokens[i].type == RPAREN) {
             --top;
         } else if (tokens[i].type == NUMBER || tokens[i].type == UMINUS) {
             stack[++top] = tokens[i].value;
         } else if (tokens[i].type == PLUS || tokens[i].type == MINUS ||
                    tokens[i].type == MUL || tokens[i].type == DIV) {
             double rightOperand = stack[top--];
             double leftOperand = stack[top--];
             switch (tokens[i].type) {
                 case PLUS:
                     stack[++top] = leftOperand + rightOperand;
                     break;
                 case MINUS:
                     stack[++top] = leftOperand - rightOperand;
                     break;
                 case MUL:
                     stack[++top] = leftOperand * rightOperand;
                     break;
                 case DIV:
                     if (rightOperand == 0) {
                         return NULL; // division by zero
                     }
                     stack[++top] = leftOperand / rightOperand;
                     break;
             }
         } else {
             return NULL; // invalid token
         }
     }
-    if (top != 0) {
+    if (top != 0) {
         return NULL; // mismatched parentheses
     }
     return stack + 1;
 }

 // Evaluator function to evaluate parsed input
 double evaluator(double* stack) {
     double result = stack[0];
-    for (int i = 1; i  top; ++i) {
+    for (int i = 1; i  top; ++i) {
         switch (stack[i]) {
             case '+':
                 result += stack[i - 1];
                 break;
             case '-':
                 result -= stack[i - 1];
                 break;
             case '*':
                 result *= stack[i - 1];
                 break;
             case '/':
                 if (stack[i - 1] == 0) {
                     return 0; // division by zero
                 }
                 result /= stack[i - 1];
                 break;
         }
     }
-    return result;
+    return result;
 }

 int main() {
     char* expressions[] = {"3 + 4 * (2 - 1)", "1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
-    for (char* expression : expressions) {
+    for (char* expression : expressions) {
         Token* tokens = lexer(expression);
         if (tokens == NULL) {
             printf("Error: %s\n", expression);
             continue;
         }
         double* parsedStack = parser(tokens);
         if (parsedStack == NULL) {
             printf("Error: %s\n", expression);
             free(tokens);
             continue;
         }
-        double result = evaluator(parsedStack);
+        double result = evaluator(parsedStack);
         if (result != 0) {
             printf("%s => %f\n", expression, result);
         } else {
             printf("%s => Error\n", expression);
         }
-        free(parsedStack);
-        free(tokens);
+        free(parsedStack);
+        free(tokens);
     }
     return 0;
 }
