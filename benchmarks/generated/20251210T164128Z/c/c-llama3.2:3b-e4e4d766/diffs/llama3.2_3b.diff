--- before.c
+++ patched_before.c
@@ -4,7 +4,8 @@
 #include  string.h>
 #include  ctype.h>
 
-#include  <string.h>
+#include  string.h>
+#include  ctype.h>

 // Token type enum
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     END_OF_EXPRESSION
 } TokenType;

 // Token structure
 typedef struct {
     TokenType type;
     double value;
     char* text;
 } Token;

 // Lexer function to tokenize the input string
+Token* lexer(char* expression) {
+    int length = strlen(expression);
+    Token* tokens = malloc((length + 1) * sizeof(Token));
+    for (int i = 0; i  length; i++) {
+        if (isdigit(expression[i])) {
+            char num[10];
+            int j = 0;
+            while (i + j  length && isdigit(expression[i + j])) {
+                num[j] = expression[i + j];
+                j++;
+            }
+            tokens[i].type = NUMBER;
+            tokens[i].value = atof(num);
+            tokens[i].text = strdup(num);
+        } else if (expression[i] == '+') {
+            tokens[i].type = PLUS;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == '-') {
+            tokens[i].type = MINUS;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == '*') {
+            tokens[i].type = MUL;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == '/') {
+            tokens[i].type = DIV;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == '(') {
+            tokens[i].type = LPAREN;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == ')') {
+            tokens[i].type = RPAREN;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        } else if (expression[i] == '-') {
+            tokens[i].type = UNARY_MINUS;
+            tokens[i].value = 0.0;
+            tokens[i].text = "";
+        }
+    }
+    tokens[length].type = END_OF_EXPRESSION;
+    tokens[length].value = 0.0;
+    tokens[length].text = NULL;

+    return tokens;
 }

 // Parser function to parse the tokenized expression
 Token* parser(Token* tokens) {
     Token* stack = malloc((tokens[0].length + 1) * sizeof(Token));
     int top = -1;
     for (int i = 0; i  tokens[0].length; i++) {
         if (tokens[i].type == LPAREN) {
             stack[++top] = tokens[i];
         } else if (tokens[i].type == RPAREN) {
             while (stack[top].type != LPAREN) {
                 Token* token = stack[top--].value;
                 if (token->type == NUMBER) {
                     stack[top].value = stack[top].value + token->value;
                 } else if (token->type == PLUS || token->type == MINUS) {
                     stack[top].value += token->value;
                 } else if (token->type == MUL || token->type == DIV) {
                     stack[top].value /= token->value;
                 }
             }
             top--;
         } else if (tokens[i].type == UNARY_MINUS) {
             Token* token = stack[top--].value;
             if (token->type == NUMBER) {
                 stack[top].value = -token->value;
             }
         } else if (top > 0 && tokens[i].type == PLUS || tokens[i].type == MINUS) {
             while (stack[top].type != LPAREN && (stack[top].type == PLUS || stack[top].type == MINUS)) {
                 Token* token = stack[top--].value;
                 if (token->type == NUMBER) {
                     stack[top].value = stack[top].value + token->value;
                 } else if (token->type == PLUS || token->type == MINUS) {
                     stack[top].value += token->value;
                 }
             }
         } else {
             Token* token = malloc(sizeof(Token));
             token->type = tokens[i].type;
             token->value = tokens[i].value;
             token->text = strdup(tokens[i].text);
             if (top > 0) {
                 stack[++top] = *token;
             } else {
                 stack[top++] = *token;
             }
         }
     }

     return stack[0];
 }

 // Evaluator function to evaluate the parsed expression
 double evaluator(Token* token) {
     double result = token->value;
     if (token->type == NUMBER) {
         return result;
     } else if (token->type == PLUS || token->type == MINUS) {
         Token* operand1 = stack[0].value;
         Token* operand2 = stack[1].value;
         if (operand1->type == NUMBER && operand2->type == NUMBER) {
             return operand1->value + operand2->value;
         } else if (operand1->type == NUMBER && operand2->type == PLUS || operand2->type == MINUS) {
             return operand1->value + operand2->value;
         } else if (operand1->type == PLUS || operand1->type == MINUS && operand2->type == NUMBER) {
             return operand1->value + operand2->value;
         }
     } else if (token->type == MUL || token->type == DIV) {
         Token* operand1 = stack[0].value;
         Token* operand2 = stack[1].value;
         if (operand1->type == NUMBER && operand2->type == NUMBER) {
             return operand1->value * operand2->value;
         } else if (operand1->type == NUMBER && operand2->type == MUL || operand2->type == DIV) {
             return operand1->value * operand2->value;
         } else if (operand1->type == MUL || operand1->type == DIV && operand2->type == NUMBER) {
             return operand1->value / operand2->value;
         }
     }

     return 0.0;
 }

 int main() {
     char expressions[][20] = {"3 + 4 * (2 - 1)", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
     for (int i = 0; i  sizeof(expressions) / sizeof(expressions[0]); i++) {
         Token* tokens = lexer(expressions[i]);
         Token* parsed_token = parser(tokens);
         double result = evaluator(parsed_token);
         printf("%s => %f\n", expressions[i], result);
     }
     return 0;
 }
