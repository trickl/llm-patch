```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    UNARY_MINUS,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
} Token;

// Lexer function to tokenize the input string
Token* lexer(const char* expression) {
    int length = strlen(expression);
    Token* tokens = malloc((length + 1) * sizeof(Token));
    for (int i = 0; i < length; ++i) {
        if (isdigit(expression[i])) {
            double value = 0;
            while (i < length && isdigit(expression[i])) {
                value = value * 10 + expression[i++] - '0';
            }
            tokens[i].type = NUMBER;
            tokens[i].value = value;
        } else if (expression[i] == '+') {
            tokens[i].type = PLUS;
        } else if (expression[i] == '-') {
            tokens[i].type = MINUS;
        } else if (expression[i] == '*') {
            tokens[i].type = MUL;
        } else if (expression[i] == '/') {
            tokens[i].type = DIV;
        } else if (expression[i] == '(') {
            tokens[i].type = LPAREN;
        } else if (expression[i] == ')') {
            tokens[i].type = RPAREN;
        } else if (expression[i] == '-') {
            tokens[i].type = UNARY_MINUS;
        } else {
            return NULL; // invalid character
        }
    }
    tokens[length].type = EOF;
    return tokens;
}

// Parser function to parse the tokenized expression
void* parser(Token* tokens) {
    int length = 0;
    for (int i = 0; i < strlen(tokens[0].value); ++i) {
        if (tokens[i].type == LPAREN || tokens[i].type == RPAREN) {
            length++;
        }
    }

    // Allocate memory for the abstract syntax tree
    void* ast = malloc((length + 1) * sizeof(void*));

    // Parse the expression
    int i = 0;
    while (tokens[i].type != EOF && tokens[i].value != '\0') {
        if (tokens[i].type == LPAREN) {
            // Recursively parse the subexpression inside the parentheses
            void* subast = parser(tokens + i + 1);
            if (subast == NULL) return NULL; // error in subexpression

            // Create a node for the subexpression and add it to the AST
            ast[length++] = malloc(sizeof(void*));
            *(void**)ast[length - 1] = subast;
        } else if (tokens[i].type == RPAREN) {
            length--;
        } else if (tokens[i].type == UNARY_MINUS) {
            // Create a node for the unary minus operation
            ast[length++] = malloc(sizeof(void*));
            *(void**)ast[length - 1] = malloc(sizeof(void*));
            *(void**)ast[length - 1] = malloc(sizeof(void*));
        } else if (tokens[i].type == NUMBER) {
            // Create a node for the number
            ast[length++] = malloc(sizeof(void*));
            *(void**)ast[length - 1] = tokens[i].value;
        } else {
            // Create nodes for operators and add them to the AST
            ast[length++] = malloc(sizeof(void*));
            ast[length - 1] = malloc(sizeof(void*));
            *(void**)ast[length - 1] = tokens[i].type;
        }
        i++;
    }

    return ast;
}

// Evaluator function to evaluate the abstract syntax tree
double evaluator(void* ast) {
    if (*(void**)ast == NULL) return 0; // leaf node (number)
    if (*(void**)ast == *(void**)ast + 1) { // unary minus operator
        double value = evaluator(*(void**)ast);
        return -value;
    } else if (*(void**)ast == *(void**)ast + 2) { // binary operator
        double right = evaluator(*(void**)ast + 3);
        double left = evaluator(*(void**)ast + 1);
        switch (*(void**)ast) {
            case '+':
                return left + right;
            case '-':
                return left - right;
            case '*':
                return left * right;
            case '/':
                return left / right;
            default:
                return 0; // invalid operator
        }
    } else { // parentheses
        double result = evaluator(*(void**)ast);
        if (*(void**)ast == *(void**)ast + 1) {
            return result;
        } else {
            return -result;
        }
    }
}

int main() {
    const char* expressions[] = {"3 + 4 * (2 - 1)", "1 + 2", "2 * 3 + 4", "8 / 2 * (2 + 2)"};
    int numExpressions = sizeof(expressions) / sizeof(expressions[0]);

    for (int i = 0; i < numExpressions; ++i) {
        Token* tokens = lexer(expressions[i]);
        if (tokens == NULL) {
            printf("Error: %s\n", expressions[i]);
            continue;
        }

        void* ast = parser(tokens);
        if (ast == NULL) {
            printf("Error: %s\n", expressions[i]);
            free(tokens);
            continue;
        }

        double result = evaluator(ast);
        printf("%s => %f\n", expressions[i], result);

        // Clean up
        for (int j = 0; j < length; ++j) {
            free(ast[j]);
        }
        free(ast);
        free(tokens);
    }

    return 0;
}
```