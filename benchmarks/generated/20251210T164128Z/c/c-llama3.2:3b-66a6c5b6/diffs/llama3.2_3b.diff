--- before.c
+++ after.c
@@ -4,7 +4,8 @@
 #include  string.h>
 #include  ctype.h>
 #include  stdlib.h>

 // Token types
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
-    MUL,
+    MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     EOF
 } TokenType;

 // Token structure
 typedef struct {
     TokenType type;
     double value;
 } Token;

 // Lexer function to tokenize the input string
 Token* lexer(const char* expression) {
-    int length = strlen(expression);
+    int length = strlen(expression) + 1; // include null terminator
     Token* tokens = malloc((length + 1) * sizeof(Token));
     for (int i = 0; i < length; ++i) {
         if (isdigit(expression[i])) {
             double value = 0;
             while (i  length && isdigit(expression[i])) {
                 value = value * 10 + expression[i++] - '0';
             }
             tokens[i].type = NUMBER;
             tokens[i].value = value;
         } else if (expression[i] == '+') {
             tokens[i].type = PLUS;
         } else if (expression[i] == '-') {
             tokens[i].type = MINUS;
         } else if (expression[i] == '*') {
             tokens[i].type = MUL;
         } else if (expression[i] == '/') {
             tokens[i].type = DIV;
         } else if (expression[i] == '(') {
             tokens[i].type = LPAREN;
         } else if (expression[i] == ')') {
             tokens[i].type = RPAREN;
         } else if (expression[i] == '-') {
             tokens[i].type = UNARY_MINUS;
         } else {
             return NULL; // invalid character
         }
     }
     tokens[length].type = EOF;
     return tokens;
 }

 // Parser function to parse the tokenized expression
 void* parser(Token* tokens) {
-    int length = 0;
+    int length = strlen(tokens[0].value);
     for (int i = 0; i  length; ++i) {
         if (tokens[i].type == LPAREN || tokens[i].type == RPAREN) {
             length++;
         }
     }

     // Allocate memory for the abstract syntax tree
     void* ast = malloc((length + 1) * sizeof(void*));

     // Parse the expression
     int i = 0;
     while (tokens[i].type != EOF && tokens[i].value != '\0') {
-        if (tokens[i].type == LPAREN) {
+        if (tokens[i].type == LPAREN) {
             // Recursively parse the subexpression inside the parentheses
             void* subast = parser(tokens + i + 1);
             if (subast == NULL) return NULL; // error in subexpression

             // Create a node for the subexpression and add it to the AST
             ast[length++] = malloc(sizeof(void*));
             *(void**)ast[length - 1] = subast;
         } else if (tokens[i].type == RPAREN) {
             length--;
         } else if (tokens[i].type == UNARY_MINUS) {
             // Create a node for the unary minus operation
             ast[length++] = malloc(sizeof(void*));
             ast[length - 1] = malloc(sizeof(void*));
             *(void**)ast[length - 1] = malloc(sizeof(void*));
         } else if (tokens[i].type == NUMBER) {
             // Create a node for the number
             ast[length++] = malloc(sizeof(void*));
             *(void**)ast[length - 1] = tokens[i].value;
         } else {
-            // Create nodes for operators and add them to the AST
+            // Create nodes for operators and add them to the AST
             ast[length++] = malloc(sizeof(void*));
             ast[length - 1] = malloc(sizeof(void*));
             *(void**)ast[length - 1] = tokens[i].type;
         }
         i++;
     }

     return ast;
 }

 // Evaluator function to evaluate the abstract syntax tree
 double evaluator(void* ast) {
-    if (*(void**)ast == NULL) return 0; // leaf node (number)
+    if (*(void**)ast == NULL || *(void**)ast == *(void**)ast + 1) { // leaf node (number) or unary minus operator
         return 0;
     }
     if (*(void**)ast == *(void**)ast + 2) { // binary operator
         double right = evaluator(*(void**)ast + 3);
         double left = evaluator(*(void**)ast + 1);
         switch (*(void**)ast) {
             case '+':
                 return left + right;
             case '-':
                 return left - right;
             case '*':
                 return left * right;
             case '/':
                 return left / right;
             default:
                 return 0; // invalid operator
         }
     } else { // parentheses
-        double result = evaluator(*(void**)ast);
+        double result = 0;
         if (*(void**)ast == *(void**)ast + 1) {
             return result;
         } else {
             return -result;
         }
     }
 }

 int main() {
     const char* expressions[] = {"3 + 4 * (2 - 1)", "1 + 2", "2 * 3 + 4", "8 / 2 * (2 + 2)"};
     int numExpressions = sizeof(expressions) / sizeof(expressions[0]);

     for (int i = 0; i  numExpressions; ++i) {
         Token* tokens = lexer(expressions[i]);
-        if (tokens == NULL) {
+        if (tokens == NULL || *(void**)tokens != EOF) { // check for EOF
             printf("Error: %s\n", expressions[i]);
             free(tokens);
             continue;
         }

         void* ast = parser(tokens);
-        if (ast == NULL) {
+        if (ast == NULL) {
             printf("Error: %s\n", expressions[i]);
             free(tokens);
             continue;
         }

         double result = evaluator(ast);
         printf("%s => %f\n", expressions[i], result);

-        for (int j = 0; j  length; ++j) {
+        for (int j = 0; j  length; ++j) {
             free(ast[j]);
         }
         free(ast);
         free(tokens);
     }

     return 0;
 }
