```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token type enum
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* str;
} Token;

// Lexer function to tokenize the input string
Token* lexer(char* expression) {
    int len = strlen(expression);
    Token* tokens = malloc((len + 1) * sizeof(Token));
    for (int i = 0; i < len; i++) {
        if (isdigit(expression[i])) {
            char num[10];
            int j = 0;
            while (i + j < len && isdigit(expression[i + j])) {
                num[j++] = expression[i + j];
            }
            tokens[i].type = NUMBER;
            tokens[i].value = atof(num);
            tokens[i].str = strdup(num);
        } else if (expression[i] == '+') {
            tokens[i].type = PLUS;
            tokens[i].value = 0;
            tokens[i].str = "";
        } else if (expression[i] == '-') {
            tokens[i].type = MINUS;
            tokens[i].value = 0;
            tokens[i].str = "";
        } else if (expression[i] == '*') {
            tokens[i].type = MUL;
            tokens[i].value = 0;
            tokens[i].str = "";
        } else if (expression[i] == '/') {
            tokens[i].type = DIV;
            tokens[i].value = 0;
            tokens[i].str = "";
        } else if (expression[i] == '(') {
            tokens[i].type = LPAREN;
            tokens[i].value = 0;
            tokens[i].str = "";
        } else if (expression[i] == ')') {
            tokens[i].type = RPAREN;
            tokens[i].value = 0;
            tokens[i].str = "";
        }
    }
    tokens[len].type = EOF;
    tokens[len].value = 0;
    tokens[len].str = NULL;

    return tokens;
}

// Parser function to parse the tokenized expression
void* parser(Token* tokens) {
    int len = 0;
    for (int i = 0; i < strlen(tokens[0].str); i++) {
        if (tokens[i].type == LPAREN) {
            len++;
        }
    }

    void* tree = malloc((len + 1) * sizeof(void));
    int stack_size = 0;

    // Parse the expression
    for (int i = 0; i < strlen(tokens[0].str); i++) {
        if (tokens[i].type == LPAREN) {
            stack_size++;
        } else if (tokens[i].type == RPAREN) {
            stack_size--;
        }

        if (stack_size > 0 && tokens[i].type != EOF) {
            void* node = malloc(sizeof(void));
            *(void**)node = malloc(sizeof(void));
            *(void**)(*(void**)node) = malloc(sizeof(void));
            *(void***)(*(void**)(*(void**)node)) = malloc(sizeof(void));

            if (tokens[i].value == 0) {
                // Operator
                Token* op_token = lexer(tokens[i].str);
                *(void***)(*(void**)(*(void**)node)) = op_token;
            } else {
                // Operand
                Token* operand_token = lexer(tokens[i].str);
                *(void***)(*(void**)(*(void**)node)) = operand_token;
            }

            if (stack_size > 0) {
                // Append child node to parent node
                void** parent_node = *(void**)(*(void**)node);
                void*** child_node = *(void***)(parent_node);
                *(void***)(child_node) = *(void***)(*(void***)(child_node));
            }
        }
    }

    return tree;
}

// Evaluator function to evaluate the parsed expression
double evaluator(void* tree) {
    // Evaluate the expression using a stack-based approach
    double result = 0.0;
    int operator_stack_size = 0;

    void** operator_stack = malloc(sizeof(void*));
    void*** operand_stack = malloc(sizeof(void***));

    while (1) {
        if (*(void***)(operator_stack) == NULL) {
            // Pop an operator from the stack
            void** op_token = *(void**)(operator_stack);
            double op_value = 0.0;
            if (op_token->type != EOF) {
                op_value = atof(op_token->str);
            }

            // Evaluate the expression using the operator and operands
            if (operand_stack_size > 0) {
                void*** operand_node = *(void***)(operand_stack);
                double operand_value = 0.0;
                if (operand_node->type != EOF) {
                    operand_value = atof(operand_node->str);
                }

                // Apply the operator to the operands
                switch (op_value) {
                    case '+':
                        result += operand_value;
                        break;
                    case '-':
                        result -= operand_value;
                        break;
                    case '*':
                        result *= operand_value;
                        break;
                    case '/':
                        result /= operand_value;
                        break;
                }

                // Pop the operands from the stack
                void** pop_operand = *(void**)(operand_stack);
                operand_stack_size--;
                operand_stack = *(void***)(pop_operand);

                if (operand_stack_size > 0) {
                    operand_node = *(void***)(operand_stack);
                }
            } else {
                // Pop an operator from the stack
                void** op_token = *(void**)(operator_stack);
                double op_value = 0.0;
                if (op_token->type != EOF) {
                    op_value = atof(op_token->str);
                }

                // Evaluate the expression using the operator and operands
                switch (op_value) {
                    case '+':
                        result += 1.0;
                        break;
                    case '-':
                        result -= 1.0;
                        break;
                    case '*':
                        result *= 1.0;
                        break;
                    case '/':
                        result /= 1.0;
                        break;
                }

                // Pop the operator from the stack
                operator_stack_size--;
                operator_stack = *(void**)(operator_stack);
            }
        } else {
            // Push an operand onto the stack
            void*** operand_node = malloc(sizeof(void***));
            operand_node->type = NUMBER;
            operand_node->value = 0.0;
            operand_node->str = strdup("1");
            operand_stack_size++;
            operand_stack = *(void***)(operand_node);
        }
    }

    return result;
}

int main() {
    char* expressions[] = {"3 + 4 * (2 - 1)", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    int num_expressions = sizeof(expressions) / sizeof(expressions[0]);

    for (int i = 0; i < num_expressions; i++) {
        Token* tokens = lexer(expressions[i]);
        void* tree = parser(tokens);
        double result = evaluator(tree);

        printf("%s => %f\n", expressions[i], result);

        free(tokens->str);
        free(tokens);
    }

    return 0;
}
```