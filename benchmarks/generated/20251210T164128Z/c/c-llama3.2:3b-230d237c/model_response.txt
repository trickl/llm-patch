```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* str;
} Token;

// Lexer function to tokenize the input string
Token* lexer(const char* expression) {
    int length = strlen(expression);
    Token* tokens = malloc((length + 1) * sizeof(Token));
    for (int i = 0; i < length; ++i) {
        if (isdigit(expression[i])) {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {NUMBER, value, NULL};
        } else if (expression[i] == '(') {
            int start = i;
            while (i < length && expression[i] != ')') {
                ++i;
            }
            tokens[i - start] = {LPAREN, 0, NULL};
        } else if (expression[i] == '-') {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = -atof(expression + start);
            tokens[i - start] = {MINUS, value, NULL};
        } else if (expression[i] == '+') {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {PLUS, value, NULL};
        } else if (expression[i] == '*') {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {MUL, value, NULL};
        } else if (expression[i] == '/') {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {DIV, value, NULL};
        } else if (expression[i] == ')') {
            int start = i;
            while (i < length && expression[i] != '(') {
                ++i;
            }
            tokens[i - start] = {RPAREN, 0, NULL};
        } else {
            // Error handling for unknown characters
            printf("Error: Unknown character '%c'\n", expression[i]);
            exit(1);
        }
    }
    tokens[length] = {EOF, 0, NULL};
    return tokens;
}

// Parser function to parse the tokenized input
Token* parser(Token* tokens) {
    Token* current_token = &tokens[0];
    Token* output_tokens = malloc((sizeof(Token) * 100) + sizeof(Token));
    int output_index = 1;

    while (current_token->type != EOF) {
        if (current_token->type == LPAREN) {
            // Recursively parse the expression inside the parentheses
            Token* inner_expression = parser(tokens + current_token - output_tokens);
            output_tokens[output_index++] = *inner_expression;
            free(inner_expression);
            current_token++;
        } else if (current_token->type == RPAREN) {
            // Skip over the closing parenthesis
            current_token++;
        } else if (current_token->type == MINUS || current_token->type == PLUS ||
                   current_token->type == MUL || current_token->type == DIV) {
            // Find a matching operator and evaluate it
            Token* operator = NULL;
            while (operator == NULL && current_token->type != EOF) {
                if (current_token->type == MINUS || current_token->type == PLUS ||
                    current_token->type == MUL || current_token->type == DIV) {
                    operator = &tokens[current_token - output_tokens];
                }
                current_token++;
            }

            // Evaluate the expression
            double value;
            if (operator->type == MINUS) {
                value = -(*operator).value;
            } else if (operator->type == PLUS) {
                value = (*operator).value;
            } else if (operator->type == MUL) {
                value = (*operator).value;
            } else if (operator->type == DIV) {
                value = (*operator).value;
            }

            // Add the evaluated expression to the output
            output_tokens[output_index++] = {NUMBER, value, NULL};
        } else {
            // Just add the token to the output
            output_tokens[output_index++] = *current_token;
            current_token++;
        }
    }

    free(tokens);
    return output_tokens;
}

// Evaluator function to evaluate the parsed expression
double evaluator(Token* tokens) {
    double result = 0.0;
    for (int i = 1; i < tokens[output_index - 1].value; ++i) {
        if (tokens[i].type == NUMBER) {
            result += tokens[i].value;
        }
    }
    return result;
}

// Main function to run the CLI
int main() {
    const char* expressions[] = {"3 + 4 * (2 - 1)", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    for (const char* expression : expressions) {
        Token* tokens = lexer(expression);
        Token* parsed_tokens = parser(tokens);
        double result = evaluator(parsed_tokens);
        printf("%s => %f\n", expression, result);
        free(parsed_tokens);
        free(tokens);
    }
    return 0;
}
```