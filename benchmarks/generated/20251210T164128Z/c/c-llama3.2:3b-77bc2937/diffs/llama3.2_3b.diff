--- before.c
+++ patched_before.c
@@ -4,6 +4,7 @@
 #include  string.h>
+#include ctype.h>

 // Token types
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     END_OF_EXPRESSION
 } TokenType;

 // Token structure
 typedef struct {
     TokenType type;
     double value;
     char* str;
 } Token;

-// Lexer function to tokenize the input string
+// Lexer function to tokenize the input string
 Token* lexer(const char* expression) {
     Token* tokens = malloc(100 * sizeof(Token));
     int tokenIndex = 0;
     char* currentChar = expression;

     while (*currentChar != '\0') {
-        if (isdigit(*currentChar)) {
+        if (isdigit(*currentChar) || isdigit(*currentChar)) {
             // Parse number
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[tokenIndex].type = NUMBER;
             tokens[tokenIndex].value = sign * numValue;
             tokens[tokenIndex].str = NULL;

             tokenIndex++;

         } else if (*currentChar == '+') {
-            // Parse plus operator
+            // Parse addition or subtraction operator
             tokens[tokenIndex].type = PLUS;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "+";
             tokenIndex++;

         } else if (*currentChar == '-') {
-            // Parse minus operator
+            // Parse addition or subtraction operator
             tokens[tokenIndex].type = MINUS;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "-";
             tokenIndex++;

         } else if (*currentChar == '*') {
-            // Parse multiplication operator
+            // Parse multiplication or division operator
             tokens[tokenIndex].type = MUL;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "*";
             tokenIndex++;

         } else if (*currentChar == '/') {
-            // Parse division operator
+            // Parse multiplication or division operator
             tokens[tokenIndex].type = DIV;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "/";
             tokenIndex++;

         } else if (*currentChar == '(') {
-            // Parse left parenthesis
+            // Parse left parenthesis
             tokens[tokenIndex].type = LPAREN;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "(";
             tokenIndex++;

         } else if (*currentChar == ')') {
-            // Parse right parenthesis
+            // Parse right parenthesis
             tokens[tokenIndex].type = RPAREN;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = ")";
             tokenIndex++;

         } else if (*currentChar == '-') {
-            // Parse unary minus operator
+            // Parse unary minus operator
             tokens[tokenIndex].type = UNARY_MINUS;
             tokens[tokenIndex].value = 0.0;
             tokens[tokenIndex].str = "-";
             tokenIndex++;

         } else {
-            // Error: Unexpected character
+            // Error: Unexpected character
             printf("Error: Unexpected character '%c'\n", *currentChar);
             return NULL;
         }
     }

-    tokens[tokenIndex].type = END_OF_EXPRESSION;
+    tokens[tokenIndex].type = END_OF_EXPRESSION;
     tokens[tokenIndex].value = 0.0;
     tokens[tokenIndex].str = NULL;

     return tokens;
 }

 // Parser function to parse the tokenized expression
 Token* parser(Token* tokens) {
     Token* outputTokens = malloc(100 * sizeof(Token));
     int outputTokenIndex = 0;
-    double value = 0.0;

     while (tokens[tokenIndex].type != END_OF_EXPRESSION) {
-        if (tokens[tokenIndex].type == NUMBER) {
+        if (tokens[tokenIndex].type == NUMBER || tokens[tokenIndex].type == PLUS ||
+            tokens[tokenIndex].type == MINUS || tokens[tokenIndex].type == MUL ||
+            tokens[tokenIndex].type == DIV) {
             // Parse number
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[tokenIndex].type = NUMBER;
             tokens[tokenIndex].value = sign * numValue;
             tokens[tokenIndex].str = NULL;

             tokenIndex++;

         } else if (tokens[tokenIndex].type == PLUS || tokens[tokenIndex].type == MINUS) {
-            // Parse addition or subtraction operator
+            // Parse addition or subtraction operator
             Token* rightOperand = parser(tokens);
             outputTokens[outputTokenIndex].type = tokens[tokenIndex].type;
             outputTokens[outputTokenIndex].value = value;
             outputTokens[outputTokenIndex].str = tokens[tokenIndex].str;

-            if (tokens[tokenIndex].type == PLUS) {
+            if (tokens[tokenIndex].type == PLUS) {
                 value += rightOperand.value;
             } else {
                 value -= rightOperand.value;
             }

             free(rightOperand);
             tokenIndex++;
         } else if (tokens[tokenIndex].type == MUL || tokens[tokenIndex].type == DIV) {
-            // Parse multiplication or division operator
+            // Parse multiplication or division operator
             Token* rightOperand = parser(tokens);
             outputTokens[outputTokenIndex].type = tokens[tokenIndex].type;
             outputTokens[outputTokenIndex].value = value;
             outputTokens[outputTokenIndex].str = tokens[tokenIndex].str;

-            if (tokens[tokenIndex].type == MUL) {
+            if (tokens[tokenIndex].type == MUL) {
                 value *= rightOperand.value;
             } else {
                 value /= rightOperand.value;
             }

             free(rightOperand);
             tokenIndex++;
         } else if (tokens[tokenIndex].type == LPAREN) {
-            // Parse left parenthesis
+            // Parse left parenthesis
             Token* rightOperand = parser(tokens + 1);
             outputTokens[outputTokenIndex].type = tokens[tokenIndex].type;
             outputTokens[outputTokenIndex].value = value;
             outputTokens[outputTokenIndex].str = tokens[tokenIndex].str;

-            free(rightOperand);
+            free(rightOperand);
             tokenIndex++;
         } else if (tokens[tokenIndex].type == RPAREN) {
-            // Parse right parenthesis
+            // Parse right parenthesis
             break;
         } else if (tokens[tokenIndex].type == UNARY_MINUS) {
-            // Parse unary minus operator
+            // Parse unary minus operator
             Token* operand = parser(tokens + 1);
             outputTokens[outputTokenIndex].type = tokens[tokenIndex].type;
             outputTokens[outputTokenIndex].value = -operand.value;
             outputTokens[outputTokenIndex].str = tokens[tokenIndex].str;

-            free(operand);
+            free(operand);
             tokenIndex++;
         }
     }

-    outputTokens[outputTokenIndex].type = END_OF_EXPRESSION;
+    outputTokens[outputTokenIndex].type = END_OF_EXPRESSION;
     outputTokens[outputTokenIndex].value = value;
     outputTokens[outputTokenIndex].str = NULL;

     return outputTokens;
 }

 // Evaluator function to evaluate the parsed expression
 double evaluator(Token* tokens) {
-    double result = 0.0;

     for (int i = 0; i  tokenIndex; i++) {
-        if (tokens[i].type == NUMBER) {
+        if (tokens[i].type == NUMBER || tokens[i].type == PLUS ||
+            tokens[i].type == MINUS || tokens[i].type == MUL ||
+            tokens[i].type == DIV) {
             // Parse number
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = sign * numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == PLUS) {
-            // Parse addition or subtraction operator
+            // Parse addition or subtraction operator
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == MINUS) {
-            // Parse addition or subtraction operator
+            // Parse addition or subtraction operator
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == MUL) {
-            // Parse multiplication operator
+            // Parse multiplication or division operator
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == DIV) {
-            // Parse division operator
+            // Parse multiplication or division operator
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == LPAREN) {
-            // Parse left parenthesis
+            // Parse left parenthesis
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else if (tokens[i].type == RPAREN) {
-            // Parse right parenthesis
+            // Parse right parenthesis
             break;
         } else if (tokens[i].type == UNARY_MINUS) {
-            // Parse unary minus operator
+            // Parse unary minus operator
             double numValue = 0.0;
             int sign = 1;
             while (isdigit(*currentChar) || *currentChar == '.') {
                 numValue = numValue * 10 + (*currentChar - '0');
                 currentChar++;
             }
-            if (*currentChar == '-') {
+            if (*currentChar == '-' || *currentChar == '+') {
                 sign = -1;
                 currentChar++;
             }

             tokens[i].type = NUMBER;
             tokens[i].value = numValue;
             tokens[i].str = NULL;

         } else {
-            // Error: Unexpected character
+            // Error: Unexpected character
             printf("Error: Unexpected character '%c'\n", *currentChar);
             return NULL;
         }
     }

-    result = value;
+    result = outputTokens[outputTokenIndex].value;

     return result;
 }

 // Main function
 int main() {
     Token* tokens = lexer("1 + 2");
     if (tokens == NULL) {
         printf("Error: Failed to tokenize expression '1 + 2'\n");
         return 1;
     }

     double result = evaluator(tokens);
     printf("Result for '1 + 2': %f\n", result);

     free(tokens);
     return 0;
 }
