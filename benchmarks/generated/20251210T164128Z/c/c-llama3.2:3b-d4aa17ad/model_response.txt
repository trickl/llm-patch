```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token type enum
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    UNARY_MINUS,
    END_OF_EXPRESSION
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* literal;
} Token;

// Lexer function to tokenize the input expression
Token* lexer(const char* expression) {
    int length = strlen(expression);
    Token* tokens = malloc((length + 1) * sizeof(Token));
    for (int i = 0; i < length; ++i) {
        switch (expression[i]) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                tokens[i].type = NUMBER;
                tokens[i].value = expression[i] - '0';
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, &expression[i]);
                break;
            case '+':
                tokens[i].type = PLUS;
                tokens[i].value = 1.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, "+");
                break;
            case '-':
                tokens[i].type = MINUS;
                tokens[i].value = -1.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, "-");
                break;
            case '*':
                tokens[i].type = MUL;
                tokens[i].value = 1.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, "*");
                break;
            case '/':
                tokens[i].type = DIV;
                tokens[i].value = -1.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, "/");
                break;
            case '(':
                tokens[i].type = LPAREN;
                tokens[i].value = 0.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, "(");
                break;
            case ')':
                tokens[i].type = RPAREN;
                tokens[i].value = 0.0;
                tokens[i].literal = malloc(2 * sizeof(char));
                strcpy(tokens[i].literal, ")");
                break;
            case '-':
                if (i == 0 || expression[i - 1] != '(') {
                    tokens[i].type = UNARY_MINUS;
                    tokens[i].value = -1.0;
                    tokens[i].literal = malloc(2 * sizeof(char));
                    strcpy(tokens[i].literal, "-");
                }
                break;
            default:
                printf("Invalid character '%c' at position %d\n", expression[i], i);
                exit(EXIT_FAILURE);
        }
    }
    tokens[length].type = END_OF_EXPRESSION;
    return tokens;
}

// Parser function to parse the tokenized expression
double* parser(Token* tokens) {
    double result = 0.0;
    int index = 0;
    while (tokens[index].type != END_OF_EXPRESSION && tokens[index].value != 0.0) {
        switch (tokens[index].type) {
            case NUMBER:
                result += tokens[index].value;
                break;
            case PLUS:
                if (index == 0 || tokens[index - 1].type == UNARY_MINUS) {
                    result -= tokens[index].value;
                } else {
                    result += tokens[index].value;
                }
                break;
            case MINUS:
                if (index == 0 || tokens[index - 1].type == UNARY_MINUS) {
                    result += tokens[index].value;
                } else {
                    result -= tokens[index].value;
                }
                break;
            case MUL:
                if (tokens[index + 1].type != LPAREN && tokens[index + 1].type != DIV) {
                    printf("Invalid operator at position %d\n", index);
                    exit(EXIT_FAILURE);
                }
                double* temp = malloc(sizeof(double));
                *temp = parser(tokens + index + 2);
                result *= *temp;
                free(temp);
                break;
            case DIV:
                if (tokens[index + 1].type != LPAREN) {
                    printf("Invalid operator at position %d\n", index);
                    exit(EXIT_FAILURE);
                }
                double* temp2 = malloc(sizeof(double));
                *temp2 = parser(tokens + index + 3);
                result /= *temp2;
                free(temp2);
                break;
            case LPAREN:
                if (tokens[index + 1].type == RPAREN) {
                    return parser(tokens + index + 2);
                } else {
                    printf("Invalid expression at position %d\n", index);
                    exit(EXIT_FAILURE);
                }
                break;
            default:
                printf("Unknown token type '%s' at position %d\n", tokens[index].literal, index);
                exit(EXIT_FAILURE);
        }
        ++index;
    }
    return &result;
}

// Evaluator function to evaluate the parsed expression
double evaluator(double result) {
    return result;
}

int main() {
    const char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    for (const char* expression : expressions) {
        Token* tokens = lexer(expression);
        double result = parser(tokens);
        printf("%s => %f\n", expression, evaluator(result));
        free(tokens);
    }
    return EXIT_SUCCESS;
}
```