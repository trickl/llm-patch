--- before.c
+++ after.c
@@ -4,6 +4,7 @@
 #include  string.h>
+#include ctype.h>

 // Token type enumeration
 typedef enum {
     NUMBER,
     PLUS,
     MINUS,
     MUL,
     DIV,
     LPAREN,
     RPAREN,
     UNARY_MINUS,
     END_OF_EXPRESSION
 } TokenType;

 // Token structure
 typedef struct {
     TokenType type;
     double value;
 } Token;

 // Tokenizer function to tokenize the input string into tokens
 Token* tokenize(const char* expression) {
     int length = strlen(expression);
     Token* tokens = malloc((length + 1) * sizeof(Token));
     for (int i = 0; i  length; ++i) {
-         if (isdigit(expression[i])) {
+         if (isdigit(expression[i])) {
             double value = 0;
             while (i  length && isdigit(expression[i])) {
                 value = value * 10 + expression[i++] - '0';
             }
             tokens[i].type = NUMBER;
             tokens[i].value = value;
-         } else if (expression[i] == '+' || expression[i] == '-' ||
+         } else if (expression[i] == '+' || expression[i] == '-' ||
                     expression[i] == '*' || expression[i] == '/') {
             tokens[i].type = expression[i];
             tokens[i].value = 0;
-         } else if (expression[i] == '(') {
+         } else if (expression[i] == '(') {
             tokens[i].type = LPAREN;
             tokens[i].value = 0;
-         } else if (expression[i] == ')') {
+         } else if (expression[i] == ')') {
             tokens[i].type = RPAREN;
             tokens[i].value = 0;
-         } else if (expression[i] == '-') {
+         } else if (expression[i] == '-') {
             tokens[i].type = UNARY_MINUS;
             tokens[i].value = 0;
-         }
     }
     tokens[length].type = END_OF_EXPRESSION;
     tokens[length].value = 0;

     return tokens;
 }

 // Parser function to parse the tokenized expression into an abstract syntax tree (AST)
 Token* parse(Token* tokens) {
     Token* ast = malloc(sizeof(Token));
     ast->type = END_OF_EXPRESSION;
     ast->value = 0;

-         int i = 0;
+         int i = 0;
     while (tokens[i].type != END_OF_EXPRESSION) {
-             if (tokens[i].type == LPAREN) {
+             if (tokens[i].type == LPAREN) {
                 // Recursively parse the expression inside the parentheses
                 Token* sub_ast = parse(tokens + i + 1);
                 ast->value += sub_ast->value;

-                     ++i;
+                     ++i;
             } else if (tokens[i].type == UNARY_MINUS) {
-                     // Apply unary minus operation
+                     // Apply unary minus operation
                 ast->value -= tokens[i].value;
-                     ++i;
+                     ++i;
             } else {
-                     // Evaluate binary operations
+                     // Evaluate binary operations
                 Token* left = parse(tokens + i + 1);
                 double result = left->value;

-                         if (tokens[i].type == PLUS || tokens[i].type == MINUS) {
+                         if (tokens[i].type == PLUS || tokens[i].type == MINUS) {
                     result += tokens[i].value;
-             } else if (tokens[i].type == MUL || tokens[i].type == DIV) {
+             } else if (tokens[i].type == MUL || tokens[i].type == DIV) {
                     result /= tokens[i].value;
-             }
+             }
                 ast->value = result;

-                         ++i;
+                         ++i;
             }
     }

     return ast;
 }

 // Evaluator function to evaluate the abstract syntax tree (AST)
 double evaluate(Token* ast) {
     if (ast->type == NUMBER) {
         return ast->value;
     } else if (ast->type == PLUS || ast->type == MINUS ||
                 ast->type == MUL || ast->type == DIV) {
-             double left = evaluate(ast);
+             double left = evaluate(ast);
         double right = evaluate(ast + 1);

-                         if (ast->type == PLUS) {
+                         if (ast->type == PLUS) {
                     return left + right;
-             } else if (ast->type == MINUS) {
+             } else if (ast->type == MINUS) {
                     return left - right;
-             } else if (ast->type == MUL) {
+             } else if (ast->type == MUL) {
                     return left * right;
-             } else if (ast->type == DIV) {
+             } else if (ast->type == DIV) {
                     return left / right;
-             }
+             }
     }

     return 0; // Handle unknown token types
 }

 int main() {
     const char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
     int num_expressions = sizeof(expressions) / sizeof(expressions[0]);

-         for (int i = 0; i  num_expressions; ++i) {
+         for (int i = 0; i  num_expressions; ++i) {
             Token* tokens = tokenize(expressions[i]);
             Token* ast = parse(tokens);
             double result = evaluate(ast);

-                     printf("%s => %f\n", expressions[i], result);
+                     printf("%s => %f\n", expressions[i], result);

-                             free(tokens);
-                             free(ast);
+                             free(tokens);
+                             free(ast);
     }

     return 0;
 }
