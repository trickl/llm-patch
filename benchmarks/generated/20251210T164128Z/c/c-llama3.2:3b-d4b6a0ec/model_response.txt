```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* str;
} Token;

// Lexer function
Token* lexer(char* input) {
    Token* tokens = malloc(100);
    int index = 0, token_count = 1;
    while (input[index] != '\0') {
        if (isdigit(input[index])) {
            double num = 0;
            while (isdigit(input[index])) {
                num = num * 10 + input[index++] - '0';
            }
            tokens[token_count].type = NUMBER;
            tokens[token_count].value = num;
            tokens[token_count].str = malloc(5);
            sprintf(tokens[token_count].str, "%d", num);
            token_count++;
        } else if (input[index] == '+') {
            tokens[token_count].type = PLUS;
            tokens[token_count].value = 1;
            tokens[token_count].str = malloc(2);
            strcpy(tokens[token_count].str, "+");
            token_count++;
        } else if (input[index] == '-') {
            tokens[token_count].type = MINUS;
            tokens[token_count].value = -1;
            tokens[token_count].str = malloc(2);
            strcpy(tokens[token_count].str, "-");
            token_count++;
        } else if (input[index] == '*') {
            tokens[token_count].type = MUL;
            tokens[token_count].value = 1;
            tokens[token_count].str = malloc(2);
            strcpy(tokens[token_count].str, "*");
            token_count++;
        } else if (input[index] == '/') {
            tokens[token_count].type = DIV;
            tokens[token_count].value = 1;
            tokens[token_count].str = malloc(2);
            strcpy(tokens[token_count].str, "/");
            token_count++;
        } else if (input[index] == '(') {
            tokens[token_count].type = LPAREN;
            tokens[token_count].value = 0;
            tokens[token_count].str = malloc(1);
            strcpy(tokens[token_count].str, "(");
            token_count++;
        } else if (input[index] == ')') {
            tokens[token_count].type = RPAREN;
            tokens[token_count].value = 0;
            tokens[token_count].str = malloc(1);
            strcpy(tokens[token_count].str, ")");
            token_count++;
        }
        index++;
    }
    tokens[token_count].type = EOF;
    tokens[token_count].value = -1;
    tokens[token_count].str = NULL;
    return tokens;
}

// Parser function
Token* parse(Token* tokens) {
    Token* output = malloc(100);
    int index = 0, precedence = 0;
    while (tokens[index].type != EOF) {
        if (tokens[index].type == LPAREN) {
            // Handle left parenthesis
            Token* temp = parse(tokens + index + 1);
            output->value += temp->value;
            output->str = malloc(100);
            strcpy(output->str, "(");
            output->type = tokens[index].type;
        } else if (tokens[index].type == RPAREN) {
            // Handle right parenthesis
            Token* temp = parse(tokens + index - 1);
            output->value += temp->value;
            output->str = malloc(100);
            strcpy(output->str, ")");
            output->type = tokens[index].type;
        } else if (tokens[index].type == NUMBER) {
            // Handle number
            Token* temp = parse(tokens + index + 1);
            output->value += temp->value;
            output->str = malloc(100);
            strcpy(output->str, "");
            output->type = tokens[index].type;
        } else if (tokens[index].type == PLUS || tokens[index].type == MINUS) {
            // Handle operator
            Token* temp = parse(tokens + index + 1);
            output->value += temp->value * precedence;
            output->str = malloc(100);
            strcpy(output->str, "");
            output->type = tokens[index].type;
        } else if (tokens[index].type == MUL || tokens[index].type == DIV) {
            // Handle operator
            Token* temp = parse(tokens + index + 1);
            output->value += temp->value * precedence;
            output->str = malloc(100);
            strcpy(output->str, "");
            output->type = tokens[index].type;
        }
        precedence = get_precedence(tokens[index].type);
        index++;
    }
    return output;
}

// Evaluator function
double evaluate(Token* token) {
    double result = 0.0;
    if (token->type == NUMBER) {
        // Handle number
        result = token->value;
    } else if (token->type == PLUS || token->type == MINUS) {
        // Handle operator
        Token* temp = evaluate(token);
        result += temp->value;
    } else if (token->type == MUL || token->type == DIV) {
        // Handle operator
        Token* temp = evaluate(token);
        result *= temp->value;
    }
    return result;
}

// Helper function to get precedence of an operator
int get_precedence(TokenType type) {
    switch (type) {
        case PLUS:
        case MINUS:
            return 1;
        case MUL:
        case DIV:
            return 2;
        default:
            return 0;
    }
}

// Main function
void main() {
    char* expressions[] = {"3 + 4 * (2 - 1)", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    for (int i = 0; i < sizeof(expressions) / sizeof(expressions[0]); i++) {
        Token* tokens = lexer(expressions[i]);
        Token* parsed = parse(tokens);
        double result = evaluate(parsed);
        printf("%s => %f\n", expressions[i], result);
        free(tokens);
        free(parsed->str);
    }
}
```