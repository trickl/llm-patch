```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    UNARY_MINUS,
    END_OF_EXPRESSION
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* str;
} Token;

// Lexer function to tokenize the input string
Token* lexer(const char* expression) {
    int length = strlen(expression);
    Token* tokens = malloc((length + 1) * sizeof(Token));
    for (int i = 0; i < length; ++i) {
        if (isdigit(expression[i])) {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {NUMBER, value, NULL};
        } else if (expression[i] == '+') {
            tokens[i] = {PLUS, 0, "+"};
        } else if (expression[i] == '-') {
            tokens[i] = {MINUS, 0, "-"};
        } else if (expression[i] == '*') {
            tokens[i] = {MUL, 0, "*"};
        } else if (expression[i] == '/') {
            tokens[i] = {DIV, 0, "/"};
        } else if (expression[i] == '(') {
            tokens[i] = {LPAREN, 0, "("};
        } else if (expression[i] == ')') {
            tokens[i] = {RPAREN, 0, ")"};
        } else if (expression[i] == '-') {
            tokens[i] = {UNARY_MINUS, 0, "-"};
        }
    }
    tokens[length] = {END_OF_EXPRESSION, 0, NULL};

    return tokens;
}

// Parser function to parse the tokenized expression
void* parser(Token* tokens) {
    int length = 0;
    for (int i = 0; i < sizeof(tokens) / sizeof(Token); ++i) {
        if (tokens[i].type == END_OF_EXPRESSION) {
            break;
        }
        length++;
    }

    // Parse the expression
    double result = parse(tokens, 0, length);

    return &result;
}

// Evaluator function to evaluate the parsed expression
double evaluate(void* expr) {
    double result = *(double*)expr;

    if (result == 0 && *((int*)expr + 1) != 0) {
        // Handle division by zero error
        printf("Error: Division by zero\n");
        exit(1);
    }

    return result;
}

// Helper function to parse the expression
double parse(Token* tokens, int start, int length) {
    double left = parse(tokens, start + 1, length - 1);

    if (tokens[start].type == PLUS || tokens[start].type == MINUS) {
        double right = parse(tokens, start + 2, length - 2);
        return applyOperator(left, right, tokens[start].type);
    } else if (tokens[start].type == LPAREN) {
        void* expr = parser(tokens + start + 1);
        return evaluate(expr);
    }

    return left;
}

// Helper function to apply an operator
double applyOperator(double left, double right, TokenType op) {
    switch (op) {
        case PLUS:
            return left + right;
        case MINUS:
            return left - right;
        case MUL:
            return left * right;
        case DIV:
            return left / right;
        default:
            printf("Error: Invalid operator\n");
            exit(1);
    }
}

int main() {
    const char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    int numExpressions = sizeof(expressions) / sizeof(expressions[0]);

    for (int i = 0; i < numExpressions; ++i) {
        Token* tokens = lexer(expressions[i]);
        void* expr = parser(tokens);
        double result = evaluate(expr);
        printf("%s = %f\n", expressions[i], result);

        free(tokens);
    }

    return 0;
}
```