```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    UNARY_MINUS,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
} Token;

// Lexer function
Token* lexer(char* expression) {
    int length = strlen(expression);
    Token* tokens = (Token*)malloc((length + 1) * sizeof(Token));
    char* current_char = expression;
    int token_index = 0;

    while (*current_char != '\0') {
        if (*current_char >= '0' && *current_char <= '9') {
            double value = 0.0;
            while (*current_char >= '0' && *current_char <= '9') {
                value = value * 10 + (*current_char - '0');
                current_char++;
            }
            tokens[token_index].type = NUMBER;
            tokens[token_index].value = value;
            token_index++;
        } else if (*current_char == '+') {
            tokens[token_index].type = PLUS;
            token_index++;
            current_char++;
        } else if (*current_char == '-') {
            tokens[token_index].type = MINUS;
            token_index++;
            current_char++;
        } else if (*current_char == '*') {
            tokens[token_index].type = MUL;
            token_index++;
            current_char++;
        } else if (*current_char == '/') {
            tokens[token_index].type = DIV;
            token_index++;
            current_char++;
        } else if (*current_char == '(') {
            tokens[token_index].type = LPAREN;
            token_index++;
            current_char++;
        } else if (*current_char == ')') {
            tokens[token_index].type = RPAREN;
            token_index++;
            current_char++;
        } else if (*current_char == '-') {
            tokens[token_index].type = UNARY_MINUS;
            token_index++;
            current_char++;
        } else {
            break;
        }
    }

    tokens[token_index].type = EOF;
    return tokens;
}

// Parser function
Token* parse(Token* tokens) {
    Token* stack = (Token*)malloc((tokens[0].type == EOF ? 1 : tokens[0].type + 1) * sizeof(Token));
    int top = -1;

    while (tokens[top = top + 1] != EOF && tokens[top].type != UNARY_MINUS) {
        if (tokens[top].type == LPAREN) {
            Token* sub_expression = parse(tokens + top + 1);
            stack[++top] = *sub_expression;
        } else if (tokens[top].type == NUMBER || tokens[top].type == PLUS || tokens[top].type == MINUS ||
                   tokens[top].type == MUL || tokens[top].type == DIV) {
            Token* operand = parse(tokens + top + 1);
            stack[++top] = *operand;
        }
    }

    if (tokens[top].type == UNARY_MINUS) {
        Token* operand = parse(tokens + top + 1);
        stack[++top] = { tokens[top].type, -operand.value };
    } else {
        stack[++top] = { tokens[top].type, 0.0 };
    }

    return stack;
}

// Evaluator function
double evaluate(Token* tokens) {
    Token* stack = parse(tokens);

    while (stack[top = top - 1].type != EOF && stack[top].type != NUMBER) {
        if (stack[top].type == PLUS) {
            double operand2 = stack[++top].value;
            double operand1 = stack[++top].value;
            stack[top] = { stack[top].type, operand1 + operand2 };
        } else if (stack[top].type == MINUS) {
            double operand2 = stack[++top].value;
            double operand1 = stack[++top].value;
            stack[top] = { stack[top].type, operand1 - operand2 };
        } else if (stack[top].type == MUL) {
            double operand2 = stack[++top].value;
            double operand1 = stack[++top].value;
            stack[top] = { stack[top].type, operand1 * operand2 };
        } else if (stack[top].type == DIV) {
            double operand2 = stack[++top].value;
            double operand1 = stack[++top].value;
            stack[top] = { stack[top].type, operand1 / operand2 };
        }
    }

    return stack[top].value;
}

int main() {
    char* expressions[] = {"3 + 4 * (2 - 1)", "1 + 2", "2 * 3 + 4", "8 / 2 * (2 + 2)"};
    int num_expressions = sizeof(expressions) / sizeof(expressions[0]);

    for (int i = 0; i < num_expressions; i++) {
        Token* tokens = lexer(expressions[i]);
        double result = evaluate(tokens);
        printf("%s => %f\n", expressions[i], result);
        free(tokens);
    }

    return 0;
}
```