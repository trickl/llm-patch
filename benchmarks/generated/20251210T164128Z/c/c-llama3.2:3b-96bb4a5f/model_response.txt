```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Token types
typedef enum {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    EOF
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    double value;
    char* text;
} Token;

// Lexer function to tokenize the input string
Token* lexer(const char* expression) {
    int length = strlen(expression);
    Token* tokens = malloc((length + 1) * sizeof(Token));
    for (int i = 0; i < length; ++i) {
        if (isdigit(expression[i])) {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {NUMBER, value, NULL};
        } else if (expression[i] == '(') {
            int start = i;
            while (i < length && expression[i] != ')') {
                ++i;
            }
            tokens[i - start] = {LPAREN, 0, NULL};
        } else if (expression[i] == '-') {
            int start = i;
            while (i < length && isdigit(expression[i])) {
                ++i;
            }
            double value = atof(expression + start);
            tokens[i - start] = {MINUS, -value, NULL};
        } else if (expression[i] == '*') {
            int start = i;
            while (i < length && expression[i] != ' ') {
                ++i;
            }
            tokens[i - start] = {MUL, 0, NULL};
        } else if (expression[i] == '/') {
            int start = i;
            while (i < length && expression[i] != ' ') {
                ++i;
            }
            tokens[i - start] = {DIV, 0, NULL};
        } else if (expression[i] == '+') {
            int start = i;
            while (i < length && expression[i] != ' ') {
                ++i;
            }
            tokens[i - start] = {PLUS, 0, NULL};
        } else if (expression[i] == ' ') {
            continue;
        } else {
            return NULL;
        }
    }
    tokens[length] = {EOF, 0, NULL};
    return tokens;
}

// Parser function to parse the tokenized expression
Token* parser(Token* tokens) {
    Token* stack = malloc(sizeof(Token));
    for (int i = 0; tokens[i].type != EOF; ++i) {
        if (tokens[i].type == LPAREN) {
            stack = realloc(stack, sizeof(Token) * (stacksize + 1));
            stack[stacksize++] = tokens[i];
        } else if (tokens[i].type == RPAREN) {
            --stacksize;
            Token* temp = stack[--stacksize];
            while (temp->type != LPAREN) {
                Token* next = parser(tokens);
                if (!next) return NULL;
                temp->value += next->value;
                free(next);
            }
            free(temp);
        } else if (tokens[i].type == PLUS || tokens[i].type == MINUS ||
                   tokens[i].type == MUL || tokens[i].type == DIV) {
            Token* left = stack[--stacksize];
            while (left->type != LPAREN && left->value != 0) {
                Token* next = parser(tokens);
                if (!next) return NULL;
                left->value += next->value;
                free(next);
            }
            Token* right = parser(tokens);
            if (!right) return NULL;
            stack = realloc(stack, sizeof(Token) * (stacksize + 1));
            stack[stacksize++] = {tokens[i].type, tokens[i].value, NULL};
            for (int j = 0; j < stacksize - 1; ++j) {
                Token* temp = stack[j];
                if (temp->type == PLUS || temp->type == MINUS ||
                    temp->type == MUL || temp->type == DIV) {
                    temp->value += right->value;
                    free(right);
                    break;
                }
            }
        } else {
            return NULL;
        }
    }
    Token* result = stack[stacksize - 1];
    free(stack);
    return result;
}

// Evaluator function to evaluate the parsed expression
double evaluator(Token* token) {
    if (token->type == NUMBER) {
        return token->value;
    } else if (token->type == MINUS) {
        return -evaluator(token->text);
    }
    return 0.0;
}

int main() {
    const char* expressions[] = {"1 + 2", "2 * 3 + 4", "2 * (3 + 4)", "8 / 2 * (2 + 2)"};
    for (const char* expression : expressions) {
        Token* tokens = lexer(expression);
        if (!tokens) return 1;
        Token* result = parser(tokens);
        if (!result) return 1;
        double value = evaluator(result);
        printf("%s => %f\n", expression, value);
        free(result->text);
        free(result);
        for (int i = 0; tokens[i].type != EOF; ++i) {
            free(tokens[i].text);
            free(&tokens[i]);
        }
        free(tokens);
    }
    return 0;
}
```