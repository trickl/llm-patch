```java
import java.util.*;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        return new ExpressionEvaluator().evaluate(expression);
    }

    private static class Tokenizer implements Iterable<Token> {
        private final String expression;
        private int pos = 0;

        public Tokenizer(String expression) {
            this.expression = expression;
        }

        @Override
        public Iterator<Token> iterator() {
            return new Iterator<>() {
                @Override
                public boolean hasNext() {
                    while (pos < expression.length()) {
                        if (Character.isDigit(expression.charAt(pos))) {
                            int endPos = pos + 1;
                            while (endPos < expression.length() && Character.isDigit(expression.charAt(endPos)))
                                ++endPos;
                            yield(new Token(TokenType.NUMBER, expression.substring(pos, endPos)));
                            pos = endPos;
                        } else if (expression.charAt(pos) == '(' || expression.charAt(pos) == ')') {
                            int endPos = pos + 1;
                            while (endPos < expression.length() && (expression.charAt(endPos) != '(' && expression.charAt(endPos) != ')'))
                                ++endPos;
                            yield(new Token(TokenType.PAREN, String.valueOf(expression.charAt(pos))));
                            pos = endPos;
                        } else if (expression.charAt(pos) == '+' || expression.charAt(pos) == '-' || expression.charAt(pos) == '*' || expression.charAt(pos) == '/') {
                            int endPos = pos + 1;
                            while (endPos < expression.length() && (expression.charAt(endPos) != '+' && expression.charAt(endPos) != '-' && expression.charAt(endPos) != '*' && expression.charAt(endPos) != '/'))
                                ++endPos;
                            yield(new Token(TokenType.OPERATOR, String.valueOf(expression.charAt(pos))));
                            pos = endPos;
                        } else {
                            int endPos = pos + 1;
                            while (endPos < expression.length() && Character.isLetter(expression.charAt(endPos)))
                                ++endPos;
                            if (expression.charAt(pos) == '-') {
                                yield(new Token(TokenType.MINUS, String.valueOf(expression.charAt(pos))));
                            }
                            pos = endPos;
                        }
                    }
                }

                @Override
                public void next() {}
            };
        }

        private enum TokenType {
            NUMBER,
            OPERATOR,
            PAREN,
            MINUS
        }

        private static class Token {
            final TokenType type;
            final String value;

            Token(TokenType type, String value) {
                this.type = type;
                this.value = value;
            }
        }
    }

    public static int evaluate(String expression) {
        List<Token> tokens = new ArrayList<>(new Tokenizer(expression).iterator());
        return parse(tokens);
    }

    private static class Parser implements Iterable<Operand> {
        private final List<Token> tokens;

        public Parser(List<Token> tokens) {
            this.tokens = tokens;
        }

        @Override
            public Iterator<Operand> iterator() {
                return new Iterator<>() {
                    int pos = 0;

                    @Override
                        public boolean hasNext() {
                            while (pos < tokens.size()) {
                                if (tokens.get(pos).type == TokenType.NUMBER) {
                                    yield(new Operand(TokenType.NUMBER, tokens.get(pos).value));
                                    ++pos;
                                } else if (tokens.get(pos).type == TokenType.OPERATOR) {
                                    int endPos = pos + 1;
                                    while (endPos < tokens.size() && (tokens.get(endPos).type != TokenType.OPERATOR || precedence(tokens.get(endPos).type) > precedence(tokens.get(pos).type)))
                                        ++endPos;
                                    yield(new Operand(TokenType.OPERATOR, String.valueOf(tokens.get(pos).value)));
                                    pos = endPos;
                                } else if (tokens.get(pos).type == TokenType.PAREN) {
                                    int endPos = pos + 1;
                                    while (endPos < tokens.size() && tokens.get(endPos).type != TokenType.PAREN)
                                        ++endPos;
                                    yield(new Operand(TokenType.PAREN, String.valueOf(tokens.get(pos).value)));
                                    pos = endPos + 1;
                                } else if (tokens.get(pos).type == TokenType.MINUS) {
                                    yield(new Operand(TokenType.MINUS, tokens.get(pos).value));
                                    ++pos;
                                }
                            }
                        }

                    @Override
                        public void next() {}
                };
        }

        private static int precedence(TokenType type) {
            switch (type) {
                case NUMBER:
                    return 0;
                case OPERATOR:
                    if (type.equals(TokenType.OPERATOR))
                        return getPrecedence(type);
                    else
                        throw new RuntimeException("Invalid operator");
                default:
                    throw new RuntimeException("Invalid operand");
            }
        }

        private static int getPrecedence(TokenType type) {
            switch (type) {
                case NUMBER:
                    return 0;
                case OPERATOR:
                    if (type.equals(TokenType.OPERATOR))
                        return getPrecedence(type);
                    else
                        throw new RuntimeException("Invalid operator");
                default:
                    throw new RuntimeException("Invalid operand");
            }
        }

        private static class Operand {
            final TokenType type;
            final String value;

            Operand(TokenType type, String value) {
                this.type = type;
                this.value = value;
            }
        }
    }

    public static int parse(List<Token> tokens) {
        List<Operand> operands = new ArrayList<>();
        while (tokens.iterator().hasNext()) {
            if (tokens.get(tokens.iterator().next()).type == TokenType.NUMBER || tokens.get(tokens.iterator().next()).type == TokenType.MINUS)
                operands.add(new Operand(tokens.get(tokens.iterator().next()).type, tokens.get(tokens.iterator().next()).value));
            else
                break;
        }
        return evaluate(operands);
    }

    private static int evaluate(List<Operand> operands) {
        Stack<Integer> stack = new Stack<>();
        for (Operand operand : operands) {
            if (operand.type == TokenType.NUMBER)
                stack.push(Integer.parseInt(operand.value));
            else if (operand.type == TokenType.OPERATOR) {
                int right = stack.pop();
                int left = stack.pop();
                switch (operand.value) {
                    case "+":
                        stack.push(left + right);
                        break;
                    case "-":
                        stack.push(left - right);
                        break;
                    case "*":
                        stack.push(left * right);
                        break;
                    case "/":
                        if (right == 0)
                            throw new RuntimeException("Division by zero");
                        stack.push(left / right);
                        break;
                }
            } else if (operand.type == TokenType.PAREN) {
                operands = parse(operands.subList(operands.indexOf(operand), operands.size()));
            }
        }
        return stack.pop();
    }
}
```