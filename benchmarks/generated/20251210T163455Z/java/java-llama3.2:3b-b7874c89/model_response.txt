```java
import java.util.*;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        return new ExpressionEvaluator().evaluate(expression);
    }

    private static class Token {
        String type;
        double value;

        Token(String type, double value) {
            this.type = type;
            this.value = value;
        }
    }

    private static class Lexer {
        List<Token> tokens;

        Lexer(String expression) {
            tokens = new ArrayList<>();
            tokenize(expression);
        }

        void tokenize(String expression) {
            int pos = 0;
            while (pos < expression.length()) {
                if (Character.isDigit(expression.charAt(pos))) {
                    double value = parseNumber();
                    addToken(new Token("NUMBER", value));
                    pos++;
                } else if (expression.charAt(pos) == '(') {
                    tokens.add(new Token("LPAREN", 0.0));
                    pos++;
                } else if (expression.charAt(pos) == ')') {
                    tokens.add(new Token("RPAREN", 0.0));
                    pos++;
                } else if (expression.charAt(pos) == '+' || expression.charAt(pos) == '-') {
                    addToken(new Token("OPERATOR", getOperator(expression.charAt(pos))));
                    pos++;
                } else if (expression.charAt(pos) == '*' || expression.charAt(pos) == '/') {
                    addToken(new Token("OPERATOR", getOperator(expression.charAt(pos))));
                    pos++;
                } else {
                    throw new RuntimeException("Invalid character: " + expression.charAt(pos));
                }
            }
        }

        private double parseNumber() {
            int start = 0;
            while (start < tokens.get(0).type.equals("NUMBER") ? tokens.get(0).value : '0') {
                if (tokens.get(0).type.equals("NUMBER")) {
                    return tokens.get(0).value * 10 + (tokens.get(0).value % 10);
                } else {
                    throw new RuntimeException("Unexpected character: " + tokens.get(0).value);
                }
            }
            int end = start;
            while (end < tokens.size() - 1 && Character.isDigit(tokens.get(end + 1).type.equals("NUMBER") ? tokens.get(end + 1).value : '0')) {
                if (tokens.get(end + 1).type.equals("NUMBER")) {
                    return tokens.get(end + 1).value * 10 + (tokens.get(end + 1).value % 10);
                } else {
                    throw new RuntimeException("Unexpected character: " + tokens.get(end + 1).value);
                }
            }
            return tokens.get(0).type.equals("NUMBER") ? tokens.get(0).value : (tokens.get(0).value * 10 + (tokens.get(0).value % 10));
        }

        private char getOperator(char c) {
            if (c == '+') {
                return '+';
            } else if (c == '-') {
                return '-';
            } else if (c == '*') {
                return '*';
            } else if (c == '/') {
                return '/';
            }
            throw new RuntimeException("Invalid operator: " + c);
        }

        void addToken(Token token) {
            tokens.add(token);
        }
    }

    private static class Parser {
        List<Token> tokens;
        Stack<Double> stack;

        Parser(List<Token> tokens, Stack<Double> stack) {
            this.tokens = tokens;
            this.stack = stack;
        }

        double parse() {
            while (!tokens.isEmpty()) {
                Token token = tokens.remove(0);
                if (token.type.equals("NUMBER")) {
                    return token.value;
                } else if (token.type.equals("LPAREN")) {
                    parse();
                    tokens.remove(0); // Remove the LPAREN
                } else if (token.type.equals("OPERATOR")) {
                    while (!tokens.isEmpty() && getPrecedence(token.value) <= getPrecedence(tokens.get(0).value)) {
                        double operand = parse();
                        stack.push(operand);
                    }
                    tokens.remove(0); // Remove the operator
                } else if (token.type.equals("RPAREN")) {
                    while (!tokens.isEmpty() && !tokens.get(0).type.equals("LPAREN")) {
                        double operand = parse();
                        stack.push(operand);
                    }
                    tokens.remove(0); // Remove the RPAREN
                    return stack.pop();
                } else {
                    throw new RuntimeException("Invalid token: " + token.type);
                }
            }
            return stack.pop();
        }

        private int getPrecedence(char operator) {
            if (operator == '*' || operator == '/') {
                return 2;
            } else if (operator == '+' || operator == '-') {
                return 1;
            }
            throw new RuntimeException("Invalid operator: " + operator);
        }
    }

    public static double evaluate(String expression) {
        Lexer lexer = new Lexer(expression);
        List<Token> tokens = lexer.tokens;
        Stack<Double> stack = new Stack<>();
        Parser parser = new Parser(tokens, stack);
        return parser.parse();
    }
}
```