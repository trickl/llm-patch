```java
import java.util.*;

public class ExpressionEvaluator {

    public static int evaluate(String expression) {
        Tokenizer tokenizer = new Tokenizer(expression);
        Parser parser = new Parser(tokenizer);
        return parser.parse();
    }

    private static class Tokenizer {
        private final String expression;
        private final List<Token> tokens;

        public Tokenizer(String expression) {
            this.expression = expression;
            tokens = tokenize(expression);
        }

        private List<Token> tokenize(String expression) {
            List<Token> tokens = new ArrayList<>();
            StringBuilder currentToken = new StringBuilder();
            for (char c : expression.toCharArray()) {
                if (Character.isWhitespace(c)) {
                    if (!currentToken.isEmpty()) {
                        tokens.add(new Token(currentToken.toString(), Token.Type.WHITE_SPACE));
                        currentToken.setLength(0);
                    }
                } else if (c == '(' || c == ')') {
                    if (!currentToken.isEmpty()) {
                        tokens.add(new Token(currentToken.toString(), Token.Type.PARENTHESIS));
                        currentToken.setLength(0);
                    }
                    tokens.add(new Token(String.valueOf(c), Token.Type.PARENTHESIS));
                } else if (Character.isDigit(c)) {
                    currentToken.append(c);
                } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                    if (!currentToken.isEmpty()) {
                        tokens.add(new Token(currentToken.toString(), Token.Type.OPERATOR));
                        currentToken.setLength(0);
                    }
                    tokens.add(new Token(String.valueOf(c), Token.Type.OPERATOR));
                } else {
                    throw new RuntimeException("Invalid character in expression: " + c);
                }
            }
            if (!currentToken.isEmpty()) {
                tokens.add(new Token(currentToken.toString(), Token.Type.WHITE_SPACE));
            }
            return tokens;
        }

        private static class Token {
            public final String value;
            public final Type type;

            public Token(String value, Type type) {
                this.value = value;
                this.type = type;
            }

            @Override
            public String toString() {
                return value;
            }

            public enum Type {
                OPERATOR,
                PARENTHESIS,
                WHITE_SPACE
            }
        }
    }

    private static class Parser {
        private final List<Token> tokens;

        public Parser(List<Token> tokens) {
            this.tokens = tokens;
        }

        public int parse() {
            return parseExpression(0);
        }

        private int parseExpression(int index) {
            int result = parseTerm(index);
            while (index < tokens.size()) {
                Token token = tokens.get(index);
                if (token.type == Token.Type.OPERATOR) {
                    switch (token.value) {
                        case "+":
                            result += parseTerm(index + 1);
                            break;
                        case "-":
                            result -= parseTerm(index + 1);
                            break;
                        case "*":
                            result *= parseTerm(index + 1);
                            break;
                        case "/":
                            result /= parseTerm(index + 1);
                            break;
                    }
                } else {
                    throw new RuntimeException("Unexpected token: " + token.value);
                }
            }
            return result;
        }

        private int parseTerm(int index) {
            int result = parseFactor(index);
            while (index < tokens.size()) {
                Token token = tokens.get(index);
                if (token.type == Token.Type.OPERATOR) {
                    switch (token.value) {
                        case "*":
                            result *= parseFactor(index + 1);
                            break;
                        case "/":
                            result /= parseFactor(index + 1);
                            break;
                    }
                } else {
                    throw new RuntimeException("Unexpected token: " + token.value);
                }
            }
            return result;
        }

        private int parseFactor(int index) {
            if (tokens.get(index).type == Token.Type.PARENTHESIS) {
                index++;
                int result = parseExpression(index);
                index++; // Close parenthesis
                return result;
            } else if (tokens.get(index).value.equals("-")) {
                index++;
                int result = -parseFactor(index);
                return result;
            } else {
                String value = tokens.get(index).value;
                try {
                    return Integer.parseInt(value);
                } catch (NumberFormatException e) {
                    throw new RuntimeException("Invalid number: " + value);
                }
            }
        }
    }

    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }
}
```