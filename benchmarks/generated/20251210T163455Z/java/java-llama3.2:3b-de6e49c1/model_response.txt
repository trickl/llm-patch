```java
import java.util.*;

public class ExpressionEvaluator {

    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        return new ExpressionEvaluator().evaluate(expression);
    }

    private static class Token {
        String type;
        Object value;

        Token(String type, Object value) {
            this.type = type;
            this.value = value;
        }
    }

    private static class Lexer {
        List<Token> tokens;

        Lexer(String expression) {
            tokens = new ArrayList<>();
            tokenize(expression);
        }

        void tokenize(String expression) {
            StringBuilder currentToken = new StringBuilder();
            for (char c : expression.toCharArray()) {
                if (Character.isWhitespace(c)) {
                    if (currentToken.length() > 0) {
                        addToken(currentToken.toString());
                        currentToken.setLength(0);
                    }
                } else if ("+-*/(). ".indexOf(c) != -1) {
                    if (currentToken.length() > 0) {
                        addToken(currentToken.toString());
                        currentToken.setLength(0);
                    }
                    tokens.add(new Token(String.valueOf(c), null));
                } else {
                    currentToken.append(c);
                }
            }
            if (currentToken.length() > 0) {
                addToken(currentToken.toString());
            }
        }

        void addToken(String token) {
            if (!token.isEmpty()) {
                tokens.add(new Token("INTEGER", Integer.parseInt(token)));
            }
        }
    }

    private static class Parser {
        List<Token> tokens;
        int pos;

        Parser(List<Token> tokens) {
            this.tokens = tokens;
            pos = 0;
        }

        Object parse() throws Exception {
            return parseExpression();
        }

        Object parseExpression() throws Exception {
            Object left = parseTerm();
            while (pos < tokens.size()) {
                Token token = tokens.get(pos);
                if (token.type.equals("INTEGER")) {
                    pos++;
                    continue;
                }
                if (token.type.equals("+") || token.type.equals("-")) {
                    String op = token.type;
                    pos++;
                    Object right = parseTerm();
                    return new ExpressionEvaluator().BinaryOp(left, op, right);
                } else if (token.type.equals("*") || token.type.equals("/")) {
                    String op = token.type;
                    pos++;
                    Object right = parseTerm();
                    return new ExpressionEvaluator().BinaryOp(left, op, right);
                } else if (token.type.equals("(")) {
                    pos++;
                    Object expr = parseExpression();
                    if (!tokens.get(pos).type.equals(")")) {
                        throw new Exception("Unbalanced parentheses");
                    }
                    pos++;
                    return expr;
                } else {
                    throw new Exception("Unexpected token: " + token.type);
                }
            }
            return left;
        }

        Object parseTerm() throws Exception {
            Object left = parseFactor();
            while (pos < tokens.size()) {
                Token token = tokens.get(pos);
                if (token.type.equals("*") || token.type.equals("/")) {
                    String op = token.type;
                    pos++;
                    Object right = parseFactor();
                    return new ExpressionEvaluator().BinaryOp(left, op, right);
                } else if (token.type.equals("(")) {
                    pos++;
                    Object expr = parseExpression();
                    if (!tokens.get(pos).type.equals(")")) {
                        throw new Exception("Unbalanced parentheses");
                    }
                    pos++;
                    return expr;
                } else {
                    break;
                }
            }
            return left;
        }

        Object parseFactor() throws Exception {
            if (pos < tokens.size()) {
                Token token = tokens.get(pos);
                if (token.type.equals("-")) {
                    pos++;
                    return new ExpressionEvaluator().UnaryOp(-1, parseTerm());
                } else if (token.type.equals("(")) {
                    pos++;
                    Object expr = parseExpression();
                    if (!tokens.get(pos).type.equals(")")) {
                        throw new Exception("Unbalanced parentheses");
                    }
                    pos++;
                    return expr;
                } else {
                    return token.value;
                }
            }
            throw new Exception("Unexpected end of input");
        }
    }

    private static class Evaluator {
        Object evaluate(Object expression) throws Exception {
            if (expression instanceof Integer) {
                return (Integer) expression;
            } else if (expression instanceof List) {
                int result = 0;
                for (Object token : (List<Object>) expression) {
                    if (token instanceof Integer) {
                        result += (int) token;
                    }
                }
                return result;
            } else {
                throw new Exception("Unsupported operand type");
            }
        }

        private static class BinaryOp {
            Object left;
            String op;
            Object right;

            BinaryOp(Object left, String op, Object right) {
                this.left = left;
                this.op = op;
                this.right = right;
            }

            int evaluate() throws Exception {
                if (op.equals("+")) {
                    return (int) left + (int) right;
                } else if (op.equals("-")) {
                    return (int) left - (int) right;
                } else if (op.equals("*")) {
                    return (int) left * (int) right;
                } else if (op.equals("/")) {
                    int leftInt = (int) left;
                    int rightInt = (int) right;
                    if (rightInt == 0) {
                        throw new ArithmeticException("Division by zero");
                    }
                    return leftInt / rightInt;
                }
                throw new Exception("Unsupported operator: " + op);
            }

            private static class UnaryOp {
                Object operand;
                int sign;

                UnaryOp(int sign, Object operand) {
                    this.operand = operand;
                    this.sign = sign;
                }

                int evaluate() throws Exception {
                    if (sign == -1) {
                        return -(int) operand;
                    } else {
                        return (int) operand;
                    }
                }
            }
        }
    }
}
```