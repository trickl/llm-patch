```java
import java.util.*;

public class ExpressionEvaluator {

    public static int evaluate(String expression) {
        List<Token> tokens = tokenize(expression);
        return parse(tokens).evaluate();
    }

    private static class Token {
        String type;
        Object value;

        Token(String type, Object value) {
            this.type = type;
            this.value = value;
        }
    }

    private static class Parser {
        private Stack<Token> operatorStack = new Stack<>();
        private List<Token> outputQueue = new ArrayList<>();

        void applyOperator(Token token) {
            while (!operatorStack.isEmpty() && getPrecedence(operatorStack.peek()) >= getPrecedence(token)) {
                Token op = operatorStack.pop();
                if (op.type.equals("UNARY_MINUS")) {
                    outputQueue.add(new Token(op.type, -(int) op.value));
                } else {
                    outputQueue.add(op);
                }
            }
            operatorStack.push(token);
        }

        void applyOperand(Token token) {
            while (!operatorStack.isEmpty() && getPrecedence(operatorStack.peek()) < getPrecedence(token)) {
                Token op = operatorStack.pop();
                if (op.type.equals("UNARY_MINUS")) {
                    outputQueue.add(new Token(op.type, -(int) op.value));
                } else {
                    outputQueue.add(op);
                }
            }
        }

        void parse(List<Token> tokens) {
            for (Token token : tokens) {
                applyOperand(token);
                if (token.type.equals("OPERATOR")) {
                    applyOperator(token);
                }
            }
            while (!operatorStack.isEmpty()) {
                Token op = operatorStack.pop();
                if (op.type.equals("UNARY_MINUS")) {
                    outputQueue.add(new Token(op.type, -(int) op.value));
                } else {
                    outputQueue.add(op);
                }
            }
        }

        int evaluate() {
            return (int) outputQueue.get(0).value;
        }

        private int getPrecedence(Token token) {
            if (token.type.equals("UNARY_MINUS")) {
                return 1;
            } else if (token.type.equals("OPERATOR") && (token.value.equals("+") || token.value.equals("-"))) {
                return 2;
            } else if (token.type.equals("OPERATOR") && token.value.equals("*") || token.value.equals("/")) {
                return 3;
            }
            return Integer.MIN_VALUE;
        }
    }

    private static class Lexer {
        String expression;

        Token nextToken() {
            while (expression.startsWith(" ")) {
                expression = expression.substring(1);
            }
            if (Character.isDigit(expression.charAt(0))) {
                StringBuilder sb = new StringBuilder();
                while (Character.isDigit(expression.charAt(sb.length()))) {
                    sb.append(expression.charAt(sb.length()));
                }
                return new Token("OPERAND", Integer.parseInt(sb.toString()));
            } else if (expression.startsWith("-")) {
                expression = expression.substring(1);
                return new Token("UNARY_MINUS", -Integer.parseInt(expression));
            } else if (expression.startsWith("(")) {
                expression = expression.substring(1);
                return new Token("PARENTHESIS", evaluate(expression));
            } else if (Character.isLetter(expression.charAt(0))) {
                StringBuilder sb = new StringBuilder();
                while (Character.isLetter(expression.charAt(sb.length()))) {
                    sb.append(expression.charAt(sb.length()));
                }
                return new Token("OPERATOR", sb.toString());
            } else {
                throw new RuntimeException("Invalid expression");
            }
        }

        int evaluate(String expression) {
            return Integer.parseInt(expression);
        }
    }

    private static List<Token> tokenize(String expression) {
        List<Token> tokens = new ArrayList<>();
        Lexer lexer = new Lexer();
        while (!expression.isEmpty()) {
            Token token = lexer.nextToken();
            if (token.type.equals("OPERAND") || token.type.equals("UNARY_MINUS")) {
                tokens.add(token);
            } else {
                throw new RuntimeException("Invalid expression");
            }
        }
        return tokens;
    }

    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }
}
```