```java
import java.util.*;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        Tokenizer tokenizer = new Tokenizer(expression);
        Parser parser = new Parser(tokenizer);
        return parser.parse().evaluate();
    }
}

class Tokenizer {
    private final String expression;
    private final List<Token> tokens;

    public Tokenizer(String expression) {
        this.expression = expression;
        tokens = tokenize(expression);
    }

    private List<Token> tokenize(String expression) {
        List<Token> tokens = new ArrayList<>();
        StringBuilder currentToken = new StringBuilder();
        for (char c : expression.toCharArray()) {
            if (Character.isWhitespace(c)) {
                if (!currentToken.isEmpty()) {
                    tokens.add(new Token(currentToken.toString(), TokenType.IDENTIFIER));
                    currentToken.setLength(0);
                }
            } else {
                currentToken.append(c);
            }
        }
        if (!currentToken.isEmpty()) {
            tokens.add(new Token(currentToken.toString(), TokenType.IDENTIFIER));
        }
        return tokens;
    }

    public List<Token> getTokens() {
        return tokens;
    }
}

enum TokenType {
    IDENTIFIER,
    OPERATOR
}

class Token {
    private final String value;
    private final TokenType type;

    public Token(String value, TokenType type) {
        this.value = value;
        this.type = type;
    }

    public String getValue() {
        return value;
    }

    public TokenType getType() {
        return type;
    }
}

class Parser {
    private final Tokenizer tokenizer;
    private final List<Token> tokens;

    public Parser(Tokenizer tokenizer) {
        this.tokenizer = tokenizer;
        this.tokens = new ArrayList<>(tokenizer.getTokens());
    }

    private void consumeToken() {
        if (tokens.isEmpty()) {
            throw new RuntimeException("Unexpected end of input");
        }
        Token token = tokens.remove(0);
        // TODO: Handle operator precedence
    }

    public Expression parse() {
        return parseExpression();
    }

    private Expression parseExpression() {
        Expression left = parseTerm();
        while (true) {
            consumeToken();
            if (!tokens.isEmpty()) {
                Operator op = getOperator(tokens.get(0).getType());
                Token right = tokens.remove(0);
                Expression rightExpr = parseExpression();
                return new BinaryOp(left, op, rightExpr);
            }
            break;
        }
    }

    private Expression parseTerm() {
        Expression left = parseFactor();
        while (true) {
            consumeToken();
            if (!tokens.isEmpty()) {
                Operator op = getOperator(tokens.get(0).getType());
                Token right = tokens.remove(0);
                Expression rightExpr = parseFactor();
                return new BinaryOp(left, op, rightExpr);
            }
            break;
        }
    }

    private Expression parseFactor() {
        if (tokens.isEmpty()) {
            throw new RuntimeException("Unexpected end of input");
        }
        Token token = tokens.get(0);
        if (token.getType() == TokenType.IDENTIFIER) {
            return new Literal(token.getValue());
        } else if (token.getType() == TokenType.OPERATOR && token.getValue().equals("-")) {
            consumeToken();
            Expression expr = parseFactor();
            consumeToken(); // -
            return new UnaryOp(expr, Operator.MINUS);
        } else {
            throw new RuntimeException("Unexpected token: " + token.getValue());
        }
    }

    private Operator getOperator(TokenType type) {
        switch (type) {
            case IDENTIFIER:
                if (tokens.get(0).getValue().equals("+")) {
                    return Operator.ADD;
                } else if (tokens.get(0).getValue().equals("-")) {
                    return Operator.SUBTRACT;
                }
                break;
            default:
                throw new RuntimeException("Unexpected operator type");
        }
    }

    public int evaluate() {
        return parse().evaluate();
    }
}

class Expression {
    private final Expression left;
    private final Operator op;
    private final Expression right;

    public Expression(Expression left, Operator op, Expression right) {
        this.left = left;
        this.op = op;
        this.right = right;
    }

    public int evaluate() {
        switch (op) {
            case ADD:
                return left.evaluate() + right.evaluate();
            case SUBTRACT:
                return left.evaluate() - right.evaluate();
            case MULTIPLY:
                return left.evaluate() * right.evaluate();
            case DIVIDE:
                if (right.evaluate() == 0) {
                    throw new ArithmeticException("Division by zero");
                }
                return left.evaluate() / right.evaluate();
        }
    }

    public static class Literal extends Expression {
        private final String value;

        public Literal(String value) {
            this.value = value;
        }

        @Override
        public int evaluate() {
            return Integer.parseInt(value);
        }
    }

    public static class UnaryOp extends Expression {
        private final Expression expr;
        private final Operator op;

        public UnaryOp(Expression expr, Operator op) {
            this.expr = expr;
            this.op = op;
        }

        @Override
        public int evaluate() {
            switch (op) {
                case MINUS:
                    return -expr.evaluate();
                default:
                    throw new RuntimeException("Unexpected operator: " + op);
            }
        }
    }

    public static class BinaryOp extends Expression {
        private final Expression left;
        private final Operator op;
        private final Expression right;

        public BinaryOp(Expression left, Operator op, Expression right) {
            this.left = left;
            this.op = op;
            this.right = right;
        }

        @Override
        public int evaluate() {
            return left.evaluate();
        }
    }
}

enum Operator {
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE
}
```