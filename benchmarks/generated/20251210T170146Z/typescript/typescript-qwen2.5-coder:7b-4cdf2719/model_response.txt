```typescript
// expression_evaluator.ts

type Token = { type: 'number' | 'operator' | 'parenthesis'; value: string };

function tokenize(input: string): Token[] {
    const tokens: Token[] = [];
    let i = 0;

    while (i < input.length) {
        if (/\s/.test(input[i])) {
            i++;
            continue;
        }

        if (/[-+*/()]/.test(input[i])) {
            tokens.push({ type: 'operator', value: input[i] });
            i++;
        } else if (/^\d+$/.test(input.slice(i))) {
            const numStart = i;
            while (i < input.length && /^\d+$/.test(input[i])) {
                i++;
            }
            tokens.push({ type: 'number', value: input.slice(numStart, i) });
        } else {
            throw new Error(`Unexpected character at position ${i}`);
        }
    }

    return tokens;
}

function parse(tokens: Token[]): number[] {
    const values: number[] = [];
    const operators: string[] = [];

    function applyOperator() {
        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
            const operator = operators.pop();
            const b = values.pop();
            const a = values.pop();
            if (operator === '+') values.push(a + b);
            else if (operator === '-') values.push(a - b);
            else if (operator === '*') values.push(a * b);
            else if (operator === '/') values.push(Math.floor(a / b));
        }
    }

    for (const token of tokens) {
        if (token.type === 'number') {
            values.push(parseInt(token.value, 10));
        } else if (token.type === 'operator') {
            while (
                operators.length > 0 &&
                precedence(operators[operators.length - 1]) >= precedence(token.value)
            ) {
                applyOperator();
            }
            operators.push(token.value);
        } else if (token.value === '(') {
            operators.push(token.value);
        } else if (token.value === ')') {
            while (operators.length > 0 && operators[operators.length - 1] !== '(') {
                applyOperator();
            }
            operators.pop(); // Remove the '('
        }
    }

    while (operators.length > 0) {
        applyOperator();
    }

    return values;
}

function precedence(operator: string): number {
    if (operator === '+' || operator === '-') return 1;
    if (operator === '*' || operator === '/') return 2;
    return 0;
}

export function evaluateExpression(input: string): number {
    const tokens = tokenize(input);
    const result = parse(tokens);
    if (result.length !== 1) throw new Error('Malformed expression');
    return result[0];
}

// CLI example
if (require.main === module) {
    const input = process.argv[2] || '3 + 4 * (2 - 1)';
    try {
        console.log(`Result of '${input}': ${evaluateExpression(input)}`);
    } catch (error) {
        console.error(error.message);
    }
}
```

This TypeScript program defines a mini calculator that can evaluate infix arithmetic expressions with parentheses, unary minus, and integer semantics. It includes functions for tokenizing the input string, parsing the tokens into an abstract syntax tree, and evaluating the expression. The program also provides a simple CLI example to demonstrate its usage.