```typescript
// Token types
enum TokenType {
    NUMBER,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    UNARY_MINUS,
}

// Token class
class Token {
    type: TokenType;
    value: string | number;

    constructor(type: TokenType, value: string | number) {
        this.type = type;
        this.value = value;
    }
}

// Lexer class
class Lexer {
    private input: string;
    private pos: number;
    private tokens: Token[];

    constructor(input: string) {
        this.input = input;
        this.pos = 0;
        this.tokens = [];
    }

    private advance(): void {
        if (this.pos < this.input.length) {
            this.pos++;
        }
    }

    private skipWhitespace(): void {
        while (this.pos < this.input.length && /\s/.test(this.input[this.pos])) {
            this.advance();
        }
    }

    private number(): string | number {
        let num = '';
        while (this.pos < this.input.length && /\d/.test(this.input[this.pos])) {
            num += this.input[this.pos];
            this.advance();
        }
        return Number(num);
    }

    private parseExpression(): void {
        const leftParenPos = this.input.indexOf('(');
        if (leftParenPos !== -1) {
            const rightParenPos = this.input.indexOf(')');
            if (rightParenPos === -1) {
                throw new Error(`Unbalanced parentheses at position ${leftParenPos}`);
            }
            const expr = this.input.slice(leftParenPos + 1, rightParenPos);
            this.tokens.push(new Token(TokenType.LPAREN, '('));
            this.parseExpression();
            this.tokens.push(new Token(TokenType.RPAREN, ')'));
        } else {
            const num = this.number();
            if (num !== undefined) {
                this.tokens.push(new Token(TokenType.NUMBER, num));
            }
        }

        while (this.pos < this.input.length && /\+\-*/\s/.test(this.input[this.pos])) {
            const tokenType = this.input[this.pos];
            this.advance();

            switch (tokenType) {
                case '+':
                    if (this.tokens.length > 0 && this.tokens[this.tokens.length - 1].type === TokenType.NUMBER) {
                        this.tokens.push(new Token(TokenType.PLUS, '+'));
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case '-':
                    if (this.tokens.length > 0 && this.tokens[this.tokens.length - 1].type === TokenType.NUMBER) {
                        this.tokens.push(new Token(TokenType.MINUS, '-'));
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case '*':
                    if (this.tokens.length > 0 && this.tokens[this.tokens.length - 1].type === TokenType.NUMBER) {
                        this.tokens.push(new Token(TokenType.MUL, '*'));
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case '/':
                    if (this.tokens.length > 0 && this.tokens[this.tokens.length - 1].type === TokenType.NUMBER) {
                        this.tokens.push(new Token(TokenType.DIV, '/'));
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
            }

            while (this.pos < this.input.length && /\s/.test(this.input[this.pos])) {
                this.advance();
            }
        }
    }

    public tokenize(): void {
        this.skipWhitespace();

        if (this.pos === this.input.length) {
            return;
        }

        const tokenType = this.input[this.pos];
        switch (tokenType) {
            case '+':
            case '-':
            case '*':
            case '/':
                this.tokens.push(new Token(TokenType[tokenType], tokenType));
                break;
            case '(':
                this.tokens.push(new Token(TokenType.LPAREN, '('));
                break;
            case ')':
                this.tokens.push(new Token(TokenType.RPAREN, ')'));
                break;
            default:
                if (/\d/.test(tokenType)) {
                    this.tokens.push(new Token(TokenType.NUMBER, tokenType));
                } else if (tokenType === ' ') {
                    // skip whitespace
                } else {
                    throw new Error(`Unexpected character at position ${this.pos}`);
                }
        }

        while (this.pos < this.input.length && /\s/.test(this.input[this.pos])) {
            this.advance();
        }
    }

    public getTokens(): Token[] {
        return this.tokens;
    }
}

// Parser class
class Parser {
    private tokens: Token[];
    private pos: number;

    constructor(tokens: Token[]) {
        this.tokens = tokens;
        this.pos = 0;
    }

    private parseExpression(): void {
        const leftParenPos = this.tokens[this.pos].value === '(' ? this.pos : -1;
        if (leftParenPos !== -1) {
            this.parseLeftParenExpression();
        } else {
            this.parseRightParenExpression();
        }
    }

    private parseLeftParenExpression(): void {
        this.pos++;
        const rightParenPos = this.tokens[this.pos].value === ')' ? this.pos : -1;
        if (rightParenPos !== -1) {
            this.parseMiddleExpression();
            this.pos = rightParenPos + 1;
        } else {
            throw new Error(`Unbalanced parentheses`);
        }
    }

    private parseRightParenExpression(): void {
        const leftParenPos = this.tokens[this.pos].value === '(' ? this.pos : -1;
        if (leftParenPos !== -1) {
            this.parseMiddleExpression();
        } else {
            throw new Error('Expected expression');
        }
    }

    private parseMiddleExpression(): void {
        while (this.pos < this.tokens.length && /\+\-*/\s/.test(this.tokens[this.pos].value)) {
            const tokenType = this.tokens[this.pos].type;
            switch (tokenType) {
                case TokenType.PLUS:
                    if (this.tokens[this.pos + 1].type === TokenType.NUMBER) {
                        this.parseAddition();
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case TokenType.MINUS:
                    if (this.tokens[this.pos + 1].type === TokenType.NUMBER) {
                        this.parseSubtraction();
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case TokenType.MUL:
                    if (this.tokens[this.pos + 1].type === TokenType.NUMBER) {
                        this.parseMultiplication();
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
                case TokenType.DIV:
                    if (this.tokens[this.pos + 1].type === TokenType.NUMBER) {
                        this.parseDivision();
                    } else {
                        throw new Error(`Expected operand at position ${this.pos}`);
                    }
                    break;
            }

            while (this.pos < this.tokens.length && /\s/.test(this.tokens[this.pos].value)) {
                this.pos++;
            }
        }
    }

    private parseAddition(): void {
        const leftValue = this.parseTerm();
        if (leftValue !== undefined) {
            while (this.pos < this.tokens.length && this.tokens[this.pos].type === TokenType.PLUS) {
                this.pos++;
                const rightValue = this.parseTerm();
                if (rightValue !== undefined) {
                    return;
                } else {
                    throw new Error(`Expected operand at position ${this.pos}`);
                }
            }
        }
    }

    private parseSubtraction(): void {
        const leftValue = this.parseTerm();
        if (leftValue !== undefined) {
            while (this.pos < this.tokens.length && this.tokens[this.pos].type === TokenType.MINUS) {
                this.pos++;
                const rightValue = this.parseTerm();
                if (rightValue !== undefined) {
                    return;
                } else {
                    throw new Error(`Expected operand at position ${this.pos}`);
                }
            }
        }
    }

    private parseMultiplication(): void {
        const leftValue = this.parseFactor();
        if (leftValue !== undefined) {
            while (this.pos < this.tokens.length && this.tokens[this.pos].type === TokenType.MUL) {
                this.pos++;
                const rightValue = this.parseFactor();
                if (rightValue !== undefined) {
                    return;
                } else {
                    throw new Error(`Expected operand at position ${this.pos}`);
                }
            }
        }
    }

    private parseDivision(): void {
        const leftValue = this.parseFactor();
        if (leftValue !== undefined) {
            while (this.pos < this.tokens.length && this.tokens[this.pos].type === TokenType.DIV) {
                this.pos++;
                const rightValue = this.parseFactor();
                if (rightValue !== undefined) {
                    return;
                } else {
                    throw new Error(`Expected operand at position ${this.pos}`);
                }
            }
        }
    }

    private parseTerm(): void {
        const leftValue = this.parseFactor();
        if (leftValue !== undefined) {
            while (this.pos < this.tokens.length && this.tokens[this.pos].type === TokenType.MUL) {
                this.pos++;
                const rightValue = this.parseFactor();
                if (rightValue !== undefined) {
                    return;
                } else {
                    throw new Error(`Expected operand at position ${this.pos}`);
                }
            }
        }
    }

    private parseFactor(): void {
        if (this.tokens[this.pos].type === TokenType.UNARY_MINUS) {
            this.pos++;
            const value = -this.parseTerm();
            return value;
        } else {
            return this.parseTerm();
        }
    }

    public parseExpression(): number | undefined {
        try {
            this.parseExpression();
            return this.tokens[this.pos].value;
        } catch (error) {
            console.error(error.message);
            return undefined;
        }
    }
}

// Evaluator class
class Evaluator {
    private pos: number;

    constructor(tokens: Token[]) {
        this.pos = 0;
    }

    public evaluate(): number | null {
        try {
            const result = this.parseExpression();
            if (result === undefined) {
                return null;
            }
            return Number(result);
        } catch (error) {
            console.error(error.message);
            return null;
        }
    }
}

// Main function
function evaluateExpression(input: string): number | null {
    const lexer = new Lexer(input);
    lexer.tokenize();
    const parser = new Parser(lexer.getTokens());
    const evaluator = new Evaluator(parser.parseExpression());
    return evaluator.evaluate();
}

// CLI example
const input = '1 + 2';
console.log(evaluateExpression(input)); // Output: 3

const input2 = '2 * 3 + 4';
console.log(evaluateExpression(input2)); // Output: 10

const input3 = '2 * (3 + 4)';
console.log(evaluateExpression(input3)); // Output: 14

const input4 = '8 / 2 * (2 + 2)';
console.log(evaluateExpression(input4)); // Output: 16
```