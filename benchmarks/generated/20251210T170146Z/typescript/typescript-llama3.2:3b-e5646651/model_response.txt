```typescript
// expression_evaluator.ts

interface Token {
  type: 'NUMBER' | 'PLUS' | 'MINUS' | 'MUL' | 'DIV' | 'LPAREN' | 'RPAREN';
  value: number | string;
}

class Evaluator {
  private precedence: { [operator: string]: number };

  constructor() {
    this.precedence = {
      '+': 1,
      '-': 1,
      '*': 2,
      '/': 2
    };
  }

  public evaluateExpression(expression: string): number {
    const tokens = this.tokenize(expression);
    return this.parse(tokens);
  }

  private tokenize(expression: string): Token[] {
    const tokens: Token[] = [];
    let currentToken = '';

    for (const char of expression) {
      if (char.match(/[0-9]/)) {
        currentToken += char;
      } else if (['+', '-', '*', '/'].includes(char)) {
        if (currentToken !== '') {
          tokens.push({ type: 'NUMBER', value: parseInt(currentToken) });
          currentToken = '';
        }
        tokens.push({
          type: char === '+' || char === '-'
            ? 'PLUS' || 'MINUS'
            : char === '*' || char === '/'
              ? 'MUL' || 'DIV'
              : 'LPAREN' || 'RPAREN',
          value: char
        });
      } else if (char === '(') {
        tokens.push({ type: 'LPAREN', value: char });
      } else if (char === ')') {
        tokens.push({ type: 'RPAREN', value: char });
      }
    }

    if (currentToken !== '') {
      tokens.push({ type: 'NUMBER', value: parseInt(currentToken) });
    }

    return tokens;
  }

  private parse(tokens: Token[]): number {
    const outputQueue = [];
    const operatorStack = [];

    for (const token of tokens) {
      if (token.type === 'NUMBER') {
        outputQueue.push(token.value);
      } else if (['LPAREN', 'PLUS', 'MINUS'].includes(token.type)) {
        while (
          operatorStack.length > 0 &&
          this.precedence[operatorStack[operatorStack.length - 1].type] >=
            this.precedence[token.type]
        ) {
          const op = operatorStack.pop();
          if (op.type === 'LPAREN') {
            throw new Error('Unbalanced parentheses');
          }
          outputQueue.push(op.value);
        }
        operatorStack.push(token);
      } else if (['MUL', 'DIV'].includes(token.type)) {
        while (
          operatorStack.length > 0 &&
          this.precedence[operatorStack[operatorStack.length - 1].type] >=
            this.precedence[token.type]
        ) {
          const op = operatorStack.pop();
          if (op.type === 'LPAREN') {
            throw new Error('Unbalanced parentheses');
          }
          outputQueue.push(op.value);
        }
        operatorStack.push(token);
      } else if (token.type === 'RPAREN') {
        while (
          operatorStack.length > 0 &&
          operatorStack[operatorStack.length - 1].type !== 'LPAREN'
        ) {
          const op = operatorStack.pop();
          outputQueue.push(op.value);
        }
        if (operatorStack.length === 0 || operatorStack[operatorStack.length - 1].type !== 'LPAREN') {
          throw new Error('Unbalanced parentheses');
        }
        operatorStack.pop(); // Remove LPAREN
      }
    }

    while (
      operatorStack.length > 0 &&
      operatorStack[operatorStack.length - 1].type !== 'LPAREN'
    ) {
      const op = operatorStack.pop();
      outputQueue.push(op.value);
    }

    if (operatorStack.length > 0) {
      throw new Error('Unbalanced parentheses');
    }

    return this.evaluate(outputQueue);
  }

  private evaluate(tokens: number[]): number {
    let result = tokens[0];

    for (let i = 1; i < tokens.length; i++) {
      const op = tokens[i];
      switch (op) {
        case '+':
          result += tokens[i + 1];
          break;
        case '-':
          result -= tokens[i + 1];
          break;
        case '*':
          result *= tokens[i + 1];
          break;
        case '/':
          result /= tokens[i + 1];
          break;
      }
      i++;
    }

    return result;
  }
}

export function evaluateExpression(input: string): number {
  const evaluator = new Evaluator();
  try {
    return evaluator.evaluateExpression(input);
  } catch (error) {
    console.error(error.message);
    return NaN; // Return Not a Number
  }
}
```