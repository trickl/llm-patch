```typescript
// expression_evaluator.ts

class ExpressionEvaluator {
  private precedence: { [operator: string]: number };

  constructor() {
    this.precedence = {
      '+': 1,
      '-': 1,
      '*': 2,
      '/': 2,
    };
  }

  public evaluateExpression(input: string): number {
    const tokens = this.tokenize(input);
    return this.parse(tokens);
  }

  private tokenize(input: string): string[] {
    const output = [];
    let currentToken = '';
    for (const char of input) {
      if (char.match(/[\d+*/()-]/)) {
        currentToken += char;
      } else if (currentToken && !this.isWhitespace(char)) {
        output.push(currentToken);
        currentToken = '';
      }
      if (!char.match(/[\d+*/()-]/)) {
        throw new Error(`Invalid character: ${char}`);
      }
    }
    if (currentToken) {
      output.push(currentToken);
    }
    return output;
  }

  private isWhitespace(char: string): boolean {
    return char === ' ' || char === '\t' || char === '\n';
  }

  private parse(tokens: string[]): number {
    const operatorStack = [];
    let outputQueue = [];

    for (const token of tokens) {
      if (!this.isOperator(token)) {
        outputQueue.push(parseInt(token));
      } else if (token === '(') {
        operatorStack.push(token);
      } else if (token === ')') {
        while (operatorStack[operatorStack.length - 1] !== '(') {
          const op = operatorStack.pop();
          outputQueue.push(op as string);
        }
        operatorStack.pop(); // Remove the '('
      } else {
        while (
          operatorStack.length &&
          this.precedence[this.getOperator(token)] >=
          this.precedence[operatorStack[operatorStack.length - 1]]
        ) {
          const op = operatorStack.pop();
          outputQueue.push(op as string);
        }
        operatorStack.push(token);
      }
    }

    while (operatorStack.length) {
      const op = operatorStack.pop();
      outputQueue.push(op as string);
    }

    return this.evaluate(outputQueue);
  }

  private getOperator(operator: string): string {
    for (const key in this.precedence) {
      if (key === operator) return key;
    }
    throw new Error(`Unknown operator: ${operator}`);
  }

  private evaluate(queue: number[]): number {
    while (queue.length >= 2) {
      const right = queue.pop() as number;
      const left = queue.pop() as number;
      let op = queue.pop() as string;

      switch (op) {
        case '+':
          queue.push(left + right);
          break;
        case '-':
          queue.push(left - right);
          break;
        case '*':
          queue.push(left * right);
          break;
        case '/':
          queue.push(Math.floor(left / right));
          break;
        default:
          throw new Error(`Invalid operator: ${op}`);
      }
    }

    return queue[0];
  }
}

export function evaluateExpression(input: string): number {
  const evaluator = new ExpressionEvaluator();
  try {
    return evaluator.evaluateExpression(input);
  } catch (error) {
    console.error(error.message);
    return NaN;
  }
}
```