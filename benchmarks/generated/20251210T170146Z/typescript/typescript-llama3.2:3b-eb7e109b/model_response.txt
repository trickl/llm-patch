```typescript
// expression_evaluator.ts

interface Token {
  type: 'NUMBER' | 'PLUS' | 'MINUS' | 'MUL' | 'DIV' | 'LPAREN' | 'RPAREN';
  value: number | string;
}

class Evaluator {
  private precedence: { [key: string]: number };

  constructor() {
    this.precedence = {
      '+': 1,
      '-': 1,
      '*': 2,
      '/': 2
    };
  }

  public tokenize(expression: string): Token[] {
    const tokens: Token[] = [];
    let currentToken = '';

    for (const char of expression) {
      if (char.match(/^[0-9+*/()-]/)) {
        currentToken += char;
      } else if (currentToken && !isNaN(Number(currentToken))) {
        tokens.push({ type: 'NUMBER', value: Number(currentToken) });
        currentToken = '';
      }

      if (char === '(' || char === ')') {
        const token = { type: char, value: '' };
        tokens.push(token);
      }
    }

    if (currentToken) {
      tokens.push({ type: 'NUMBER', value: Number(currentToken) });
    }

    return tokens;
  }

  public parse(tokens: Token[]): number[] {
    const outputQueue: number[] = [];
    const operatorStack: string[] = [];

    for (const token of tokens) {
      if (token.type === 'NUMBER') {
        outputQueue.push(token.value);
      } else if (['+', '-', '*', '/'].includes(token.type)) {
        while (
          operatorStack.length &&
          this.precedence[operatorStack[operatorStack.length - 1]] >=
            this.precedence[token.type]
        ) {
          const op = operatorStack.pop() as string;
          outputQueue.push(this.applyOp(op, outputQueue));
        }
        operatorStack.push(token.type);
      } else if (token.type === 'LPAREN') {
        operatorStack.push(token.type);
      } else if (token.type === 'RPAREN') {
        while (operatorStack[operatorStack.length - 1] !== 'LPAREN') {
          const op = operatorStack.pop() as string;
          outputQueue.push(this.applyOp(op, outputQueue));
        }
        operatorStack.pop();
      }
    }

    while (operatorStack.length) {
      const op = operatorStack.pop() as string;
      outputQueue.push(this.applyOp(op, outputQueue));
    }

    return outputQueue;
  }

  private applyOp(op: string, queue: number[]): number {
    if (op === '+') {
      return queue[queue.length - 1] + queue.pop()!;
    } else if (op === '-') {
      return -queue.pop()! + queue[queue.length - 1];
    } else if (op === '*') {
      const right = queue.pop()!;
      const left = queue.pop()!;
      return left * right;
    } else if (op === '/') {
      const right = queue.pop()!;
      const left = queue.pop()!;
      return left / right;
    }
  }

  public evaluate(expression: string): number {
    const tokens = this.tokenize(expression);
    const outputQueue = this.parse(tokens);

    let result = outputQueue[0];
    for (let i = 1; i < outputQueue.length; i += 2) {
      result = this.applyOp(outputQueue[i], [result, outputQueue[i + 1]]);
    }

    return result;
  }
}

export function evaluateExpression(input: string): number {
  const evaluator = new Evaluator();
  return evaluator.evaluate(input);
}
```