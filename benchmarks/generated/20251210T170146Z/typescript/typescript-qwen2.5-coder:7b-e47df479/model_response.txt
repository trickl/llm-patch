```typescript
// expression_evaluator.ts

type Token = { type: 'number' | 'operator' | 'parenthesis', value: string };

const tokenize = (input: string): Token[] => {
    const tokens: Token[] = [];
    let i = 0;

    while (i < input.length) {
        if (/\s/.test(input[i])) {
            i++;
            continue;
        }

        if (/[-+*/()]/.test(input[i])) {
            tokens.push({ type: 'operator', value: input[i] });
            i++;
            continue;
        }

        if (/^\d+$/.test(input.slice(i))) {
            const numMatch = input.slice(i).match(/^\d+/);
            if (numMatch) {
                tokens.push({ type: 'number', value: numMatch[0] });
                i += numMatch[0].length;
            }
        }

        throw new Error(`Unexpected character at position ${i}`);
    }

    return tokens;
};

const precedence = (op: string): number => {
    if (op === '+' || op === '-') return 1;
    if (op === '*' || op === '/') return 2;
    return 0;
};

const applyOp = (a: number, b: number, op: string): number => {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return Math.floor(a / b);
        default: throw new Error(`Invalid operator ${op}`);
    }
};

const evaluate = (tokens: Token[]): number => {
    const values: number[] = [];
    const ops: string[] = [];

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === 'number') {
            values.push(parseInt(token.value, 10));
        } else if (token.type === 'operator') {
            while (ops.length && precedence(ops[ops.length - 1]) >= precedence(token.value)) {
                values.push(applyOp(values.pop()!, values.pop()!, ops.pop()!));
            }
            ops.push(token.value);
        } else if (token.value === '(') {
            ops.push(token.value);
        } else if (token.value === ')') {
            while (ops.length && ops[ops.length - 1] !== '(') {
                values.push(applyOp(values.pop()!, values.pop()!, ops.pop()!));
            }
            ops.pop();
        }
    }

    while (ops.length) {
        values.push(applyOp(values.pop()!, values.pop()!, ops.pop()!));
    }

    return values[0];
};

export const evaluateExpression = (input: string): number => {
    try {
        const tokens = tokenize(input);
        return evaluate(tokens);
    } catch (error) {
        console.error(`Error evaluating expression: ${error.message}`);
        throw error;
    }
};

// CLI example
if (require.main === module) {
    const input = process.argv[2];
    if (!input) {
        console.log('Usage: node expression_evaluator.ts "expression"');
        process.exit(1);
    }

    try {
        const result = evaluateExpression(input);
        console.log(`Result: ${result}`);
    } catch (error) {
        // Error handling already done in evaluateExpression
    }
}
```