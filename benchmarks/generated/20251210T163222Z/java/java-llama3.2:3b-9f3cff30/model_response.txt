```java
import java.util.*;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        System.out.println(evaluate("1 + 2")); // 3
        System.out.println(evaluate("2 * 3 + 4")); // 10
        System.out.println(evaluate("2 * (3 + 4)")); // 14
        System.out.println(evaluate("8 / 2 * (2 + 2)")); // 16
    }

    public static int evaluate(String expression) {
        return new ExpressionEvaluator().evaluate(expression);
    }

    private class Token {
        String type;
        double value;

        Token(String type, double value) {
            this.type = type;
            this.value = value;
        }
    }

    private class Lexer {
        List<Token> tokens;

        Lexer(String expression) {
            tokens = new ArrayList<>();
            tokenize(expression);
        }

        void tokenize(String expression) {
            StringBuilder currentToken = new StringBuilder();
            for (char c : expression.toCharArray()) {
                if (Character.isWhitespace(c)) {
                    if (!currentToken.isEmpty()) {
                        addToken(currentToken.toString());
                        currentToken.setLength(0);
                    }
                } else if (c == '(' || c == ')') {
                    if (!currentToken.isEmpty()) {
                        addToken(currentToken.toString());
                        currentToken.setLength(0);
                    }
                    tokens.add(new Token(String.valueOf(c), 0));
                } else if (Character.isDigit(c)) {
                    currentToken.append(c);
                } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                    if (!currentToken.isEmpty()) {
                        addToken(currentToken.toString());
                        currentToken.setLength(0);
                    }
                    tokens.add(new Token(String.valueOf(c), 0));
                }
            }
            if (!currentToken.isEmpty()) {
                addToken(currentToken.toString());
            }
        }

        void addToken(String token) {
            try {
                double value = Double.parseDouble(token);
                tokens.add(new Token("NUMBER", value));
            } catch (NumberFormatException e) {
                tokens.add(new Token("OPERATOR", 0));
            }
        }
    }

    private class Parser {
        List<Token> tokens;
        Stack<Double> stack;

        Parser(List<Token> tokens, Stack<Double> stack) {
            this.tokens = tokens;
            this.stack = stack;
        }

        void parse() {
            while (!tokens.isEmpty()) {
                Token token = tokens.remove(0);
                if (token.type.equals("NUMBER")) {
                    stack.push(token.value);
                } else if (token.type.equals("OPERATOR")) {
                    double rightOperand = stack.pop();
                    double leftOperand = stack.pop();
                    double result;
                    switch (token.value) {
                        case '+':
                            result = leftOperand + rightOperand;
                            break;
                        case '-':
                            result = leftOperand - rightOperand;
                            break;
                        case '*':
                            result = leftOperand * rightOperand;
                            break;
                        case '/':
                            if (rightOperand == 0) {
                                throw new RuntimeException("Division by zero");
                            }
                            result = leftOperand / rightOperand;
                            break;
                    }
                    stack.push(result);
                } else if (token.type.equals("(")) {
                    tokens.remove(0); // consume '('
                    Parser parser = new Parser(tokens, stack);
                    parser.parse();
                    tokens.add(new Token(")", 0));
                } else {
                    throw new RuntimeException("Invalid token: " + token.value);
                }
            }
        }

        double evaluate() {
            parse();
            return stack.pop();
        }
    }

    public int evaluate(String expression) {
        Lexer lexer = new Lexer(expression);
        List<Token> tokens = lexer.tokens;
        Stack<Double> stack = new Stack<>();
        Parser parser = new Parser(tokens, stack);
        return (int) parser.evaluate();
    }
}
```