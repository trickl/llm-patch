```python
import re

class Token:
    def __init__(self, type, value):
        self.type = type
        self.value = value

class Tokenizer:
    def tokenize(self, expression):
        tokens = []
        current_token = None
        for char in expression:
            if char.isspace():
                continue
            if not current_token or (current_token.type == 'NUMBER' and char.isdigit()):
                current_token = Token('NUMBER', char)
            elif not current_token or (current_token.type != 'OPERATOR' and char in '+-*/()'):
                if current_token:
                    tokens.append(current_token)
                current_token = Token(char, None)
            else:
                current_token.value += char
        if current_token:
            tokens.append(current_token)
        return tokens

class Parser:
    def __init__(self):
        self precedence = {'+': 1, '-': 1, '*': 2, '/': 2}

    def parse(self, tokens):
        output_queue = []
        operator_stack = []

        for token in tokens:
            if token.type == 'NUMBER':
                output_queue.append(token.value)
            elif token.type == 'OPERATOR':
                while (operator_stack and 
                       self.precedence[operator_stack[-1]] >= self.precedence[token.value]):
                    output_queue.append(operator_stack.pop())
                operator_stack.append(token.value)
            elif token.type == 'LPAREN':
                operator_stack.append(token.value)
            elif token.type == 'RPAREN':
                while operator_stack and operator_stack[-1] != 'LPAREN':
                    output_queue.append(operator_stack.pop())

        while operator_stack:
            output_queue.append(operator_stack.pop())

        return self.evaluate(output_queue)

    def evaluate(self, tokens):
        stack = []
        for token in tokens:
            if isinstance(token, int):
                stack.append(token)
            elif token == 'LPAREN':
                stack.append(None)
            elif token == 'RPAREN':
                while stack and stack[-1] != None:
                    operand2 = stack.pop()
                    operand1 = stack.pop()
                    result = self.apply_operator(operand1, operand2, token)
                    if isinstance(result, int):
                        stack.append(result)
                    else:
                        raise ValueError("Invalid expression")
            elif token in '+-*/':
                while len(stack) >= 2 and stack[-1] != None and stack[-2] != None:
                    operand2 = stack.pop()
                    operand1 = stack.pop()
                    result = self.apply_operator(operand1, operand2, token)
                    if isinstance(result, int):
                        stack.append(result)
                    else:
                        raise ValueError("Invalid expression")
        return stack[0]

    def apply_operator(self, operand1, operand2, operator):
        if operator == '+':
            return operand1 + operand2
        elif operator == '-':
            return operand1 - operand2
        elif operator == '*':
            return operand1 * operand2
        elif operator == '/':
            return operand1 / operand2

class Evaluator:
    def evaluate(self, expression):
        tokens = Tokenizer().tokenize(expression)
        parser = Parser()
        result = parser.parse(tokens)
        if not isinstance(result, int):
            raise ValueError("Invalid expression")
        return result

if __name__ == '__main__':
    print(Evaluator().evaluate('1 + 2'))  # Output: 3
    print(Evaluator().evaluate('2 * 3 + 4'))  # Output: 10
    print(Evaluator().evaluate('2 * (3 + 4)'))  # Output: 14
    print(Evaluator().evaluate('8 / 2 * (2 + 2)'))  # Output: 16
```